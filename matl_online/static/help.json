{
	"data": [
		{
			"source": "<strong>!<\/strong>",
			"in": "1--2 (1 \/ 2)",
			"out": "1",
			"description": "    If 1 input: <strong>.'<\/strong> (<strong>transpose<\/strong>), or <strong>permute(..., [2 1 ...])<\/strong> for \n    multidimensional arrrays. If 2 inputs: <strong>permute<\/strong>. If the second \n    input is 1, 2 or 3 it indicates which dimension is not permuted \n    for a 3D array; that is, it corresponds to [1 3 2], [3 2 1] or \n    [2 1 3] respectively ",
			"brief": "transpose \/ permute array dimensions",
			"inout": "1--2 (1 \/ 2);  1"
		},
		{
			"source": "<strong>X!<\/strong>",
			"in": "1--2 (2)",
			"out": "1",
			"description": "    <strong>rot90<\/strong> ",
			"brief": "rotate array 90 degrees",
			"inout": "1--2 (2);  1"
		},
		{
			"source": "<strong>Y!<\/strong>",
			"in": "1",
			"out": "0--2 (2)",
			"description": "    <strong>system<\/strong> ",
			"brief": "execute system command",
			"inout": "1;  0--2 (2)"
		},
		{
			"source": "<strong>Z!<\/strong>",
			"in": "1",
			"out": "1",
			"description": "    <strong>full<\/strong> ",
			"brief": "convert sparse matrix to full matrix",
			"inout": "1;  1"
		},
		{
			"source": "<strong>\"<\/strong>",
			"in": null,
			"out": null,
			"description": "    <strong>for<\/strong> (control flow: loop). See also <strong>]<\/strong>, <strong>@<\/strong>, <strong>X@<\/strong>, <strong>.<\/strong>, <strong>X.<\/strong> ",
			"brief": "for",
			"inout": ";  "
		},
		{
			"source": "<strong>X\"<\/strong>",
			"in": "2-- (3)",
			"out": "1",
			"description": "    <strong>repmat<\/strong> ",
			"brief": "replicate and tile array",
			"inout": "2-- (3);  1"
		},
		{
			"source": "<strong>Y\"<\/strong>",
			"in": "2-- (2)",
			"out": "1",
			"description": "    <strong>repelem<\/strong> (run-length decoding) ",
			"brief": "replicate elements of array",
			"inout": "2-- (2);  1"
		},
		{
			"source": "<strong>Z\"<\/strong>",
			"in": "1",
			"out": "1",
			"description": "    <strong>blanks<\/strong>. It allows vector input, and in that case it produces a \n    matrix or multidimensional array ",
			"brief": "string or array of blanks",
			"inout": "1;  1"
		},
		{
			"source": "<strong>#<\/strong>",
			"in": null,
			"out": null,
			"description": "    specify outputs for next function ",
			"brief": "output specification",
			"inout": ";  "
		},
		{
			"source": "<strong>X#<\/strong>",
			"in": "0",
			"out": "0",
			"description": "    display stack as a cell array ",
			"brief": "display stack contents",
			"inout": "0;  0"
		},
		{
			"source": "<strong>Z#<\/strong>",
			"in": "1--3 (1)",
			"out": "0",
			"description": "    Appends first input to file <strong>inout<\/strong>, creating it if necessary. If \n    the input is an array it is converted to char and written. If \n    the input is a cell array input, the contents of each cell are \n    converted to char and written, with a newline (character 10) in \n    between. With 2 inputs: second input specifies filename; it is \n    converted to char is necessary; if empty defaults to <strong>inout<\/strong>. With \n    3 inputs: third input specifies whether any previous contents of \n    file should be kept. The file is guaranteed to be deleted at the \n    beginning of the program ",
			"brief": "write to file",
			"inout": "1--3 (1);  0"
		},
		{
			"source": "<strong>$<\/strong>",
			"in": null,
			"out": null,
			"description": "    specify inputs for next function ",
			"brief": "input specification",
			"inout": ";  "
		},
		{
			"source": "<strong>X$<\/strong>",
			"in": "1-- (2 \/ 2)",
			"out": "0-- (1)",
			"description": "    execute Matlab function specified by first input, using the rest \n    of the inputs as arguments. ",
			"brief": "execute Matlab function",
			"inout": "1-- (2 \/ 2);  0-- (1)"
		},
		{
			"source": "<strong>Y$<\/strong>",
			"in": "1--2 (2)",
			"out": "1",
			"description": "    <strong>char(vpa(...))<\/strong> ",
			"brief": "variable precision arithmetic",
			"inout": "1--2 (2);  1"
		},
		{
			"source": "<strong>Z$<\/strong>",
			"in": "0--1 (0)",
			"out": "1",
			"description": "    Reads bytes from specifed file. The output is a row vector of \n    char. If 0 inputs or empty input: file name is <strong>inout<\/strong>. ",
			"brief": "read from file",
			"inout": "0--1 (0);  1"
		},
		{
			"source": "<strong>%<\/strong>",
			"in": null,
			"out": null,
			"description": "    comment. The rest of the line is ignored ",
			"brief": "comment",
			"inout": ";  "
		},
		{
			"source": "<strong>X%<\/strong>",
			"in": "1",
			"out": "1",
			"description": "    class of input (<strong>class<\/strong> with one input) ",
			"brief": "class",
			"inout": "1;  1"
		},
		{
			"source": "<strong>Y%<\/strong>",
			"in": "2--3 (2)",
			"out": "1",
			"description": "    <strong>cast<\/strong> ",
			"brief": "cast to data type",
			"inout": "2--3 (2);  1"
		},
		{
			"source": "<strong>Z%<\/strong>",
			"in": "2",
			"out": "1",
			"description": "    <strong>typecast<\/strong> ",
			"brief": "convert datatypes without changing underlying data",
			"inout": "2;  1"
		},
		{
			"source": "<strong>&<\/strong>",
			"in": null,
			"out": null,
			"description": "    alternative specification of inputs and outputs for next \n    function ",
			"brief": "alternative input\/output specification",
			"inout": ";  "
		},
		{
			"source": "<strong>X&<\/strong>",
			"in": "2--4 (2 \/ 3)",
			"out": "1--3 (1)",
			"description": "    <strong>intersect<\/strong>. Uses the <strong>'stable'<\/strong> flag by default. If one input is \n    char and the other is numeric, the latter is converted to char. \n    This function allows flag strings in third and subsequent inputs \n    to be replaced by numbers, as follows: 1: <strong>'rows'<\/strong>, 2: <strong>'stable'<\/strong>, \n    3: <strong>'sorted'<\/strong> ",
			"brief": "set intersection",
			"inout": "2--4 (2 \/ 3);  1--3 (1)"
		},
		{
			"source": "<strong>Y&<\/strong>",
			"in": "0-- (2 \/ number of elements in stack)",
			"out": "1",
			"description": "    <strong>&<\/strong> (<strong>and<\/strong>), element-wise with singleton expansion ",
			"brief": "logical 'and' (element-wise, singleton expansion)",
			"inout": "0-- (2 \/ number of elements in stack);  1"
		},
		{
			"source": "<strong>Z&<\/strong>",
			"in": "2--3 (2)",
			"out": "1",
			"description": "    <strong>bitand<\/strong>, element-wise with singleton expansion. If first or \n    second inputs are <strong>char<\/strong> they are automatically converted to \n    <strong>double<\/strong> ",
			"brief": "bit-wise logical 'and' (element-wise, singleton expansion)",
			"inout": "2--3 (2);  1"
		},
		{
			"source": "<strong>'<\/strong>",
			"in": null,
			"out": null,
			"description": "    string delimiter. Should be doubled when used within a string ",
			"brief": "string delimiter",
			"inout": ";  "
		},
		{
			"source": "<strong>Y'<\/strong>",
			"in": "1",
			"out": "2 (2 \/ second)",
			"description": "    run-length encoding (inverse of <strong>repelem<\/strong>). Input may be an array \n    or cell array. Numeric values must be finite ",
			"brief": "run-length encoding",
			"inout": "1;  2 (2 \/ second)"
		},
		{
			"source": "<strong>Z'<\/strong>",
			"in": "0--1 (0 \/ 1)",
			"out": "1",
			"description": "    <strong>now<\/strong>. With 1 input: the input should be numeric with values from \n    1 to 6, which are used as indices into the output of <strong>clock<\/strong> ",
			"brief": "current date and time",
			"inout": "0--1 (0 \/ 1);  1"
		},
		{
			"source": "<strong>(<\/strong>",
			"in": "3-- (3 \/ 4)",
			"out": "1",
			"description": "    assignment <strong>( )<\/strong> indexing. Null assignment (<strong>x(...) = []<\/strong>) can only \n    be done with a single index ",
			"brief": "assignment ( ) indexing",
			"inout": "3-- (3 \/ 4);  1"
		},
		{
			"source": "<strong>X(<\/strong>",
			"in": "3-- (3)",
			"out": "1",
			"description": "    assignment <strong>{ }<\/strong> indexing ",
			"brief": "assignment {} indexing",
			"inout": "3-- (3);  1"
		},
		{
			"source": "<strong>Y(<\/strong>",
			"in": "2-- (3)",
			"out": "1",
			"description": "    assignment <strong>(..., :)<\/strong> indexing. Null assignment (<strong>x(..., :) = []<\/strong>) \n    can only be done with a single index (in addition to the \n    implicit colon) ",
			"brief": "assignment ( ) indexing with final colon",
			"inout": "2-- (3);  1"
		},
		{
			"source": "<strong>Z(<\/strong>",
			"in": "2-- (3)",
			"out": "1",
			"description": "    assignment <strong>(:, ...)<\/strong> indexing. Null assignment (<strong>x(:, ...) = []<\/strong>) \n    can only be done with a single index (in addition to the \n    implicit colon) ",
			"brief": "assignment ( ) indexing with initial colon",
			"inout": "2-- (3);  1"
		},
		{
			"source": "<strong>)<\/strong>",
			"in": "2-- (2)",
			"out": "1--2 (1 \/ 2)",
			"description": "    reference <strong>( )<\/strong> indexing. If 2 outputs: only one input index can \n    be used. The second output produces the \"complementary\" array \n    <strong>y=x; y(ind)=[]<\/strong>, where <strong>y<\/strong> and <strong>ind<\/strong> are the inputs ",
			"brief": "reference ( ) indexing \/ split array",
			"inout": "2-- (2);  1--2 (1 \/ 2)"
		},
		{
			"source": "<strong>X)<\/strong>",
			"in": "2-- (2)",
			"out": "0-- (number of elements that will be produced)",
			"description": "    reference <strong>{ }<\/strong> indexing ",
			"brief": "reference {} indexing",
			"inout": "2-- (2);  0-- (number of elements that will be produced)"
		},
		{
			"source": "<strong>Y)<\/strong>",
			"in": "1-- (2)",
			"out": "1--2 (1 \/ 2)",
			"description": "    reference <strong>(..., :)<\/strong> indexing. If 2 outputs: only one input index \n    can be used. The second output produces the \"complementary\" \n    array <strong>y=x; y(ind,:)=[]<\/strong>, where <strong>y<\/strong> and <strong>ind<\/strong> are the inputs ",
			"brief": "reference ( ) indexing with final colon",
			"inout": "1-- (2);  1--2 (1 \/ 2)"
		},
		{
			"source": "<strong>Z)<\/strong>",
			"in": "1-- (2)",
			"out": "1--2 (1 \/ 2)",
			"description": "    reference <strong>(:, ...)<\/strong> indexing. If 2 outputs: only one input index \n    can be used. The second output produces the \"complementary\" \n    array <strong>y=x; y(:,ind)=[]<\/strong>, where <strong>y<\/strong> and <strong>ind<\/strong> are the inputs ",
			"brief": "reference ( ) indexing with initial colon",
			"inout": "1-- (2);  1--2 (1 \/ 2)"
		},
		{
			"source": "<strong>*<\/strong>",
			"in": "0-- (2 \/ number of elements in stack)",
			"out": "1",
			"description": "    <strong>.*<\/strong> (<strong>times<\/strong>), element-wise with singleton expansion ",
			"brief": "array product (element-wise, singleton expansion)",
			"inout": "0-- (2 \/ number of elements in stack);  1"
		},
		{
			"source": "<strong>X*<\/strong>",
			"in": "2",
			"out": "1",
			"description": "    <strong>kron<\/strong> ",
			"brief": "Kronecker tensor product",
			"inout": "2;  1"
		},
		{
			"source": "<strong>Y*<\/strong>",
			"in": "2",
			"out": "1",
			"description": "    matrix product, <strong>*<\/strong> (<strong>mtimes<\/strong>) ",
			"brief": "matrix product",
			"inout": "2;  1"
		},
		{
			"source": "<strong>Z*<\/strong>",
			"in": "1-- (2)",
			"out": "1",
			"description": "    Cartesian product. Given a number n of arrays of possibly \n    different sizes, generates an n-column matrix whose rows \n    describe all combinations of elements taken from those arrays ",
			"brief": "Cartesian product",
			"inout": "1-- (2);  1"
		},
		{
			"source": "<strong>+<\/strong>",
			"in": "0-- (2 \/ number of elements in stack)",
			"out": "1",
			"description": "    <strong>+<\/strong> (<strong>plus<\/strong>), element-wise with singleton expansion ",
			"brief": "addition (element-wise, singleton expansion)",
			"inout": "0-- (2 \/ number of elements in stack);  1"
		},
		{
			"source": "<strong>Y+<\/strong>",
			"in": "2--3 (2 \/ 3)",
			"out": "1",
			"description": "    <strong>conv2<\/strong>. Doesn't allow two-vector and onr matrix mode. Converts \n    first two inputs to <strong>double<\/strong>. This function allows flag strings in \n    third and subsequent inputs to be replaced by numbers, as \n    follows: 1: <strong>'same'<\/strong>, 2: <strong>'valid'<\/strong>, 3: <strong>'full'<\/strong>. See also <strong>Z+<\/strong> ",
			"brief": "two-dimensional convolution",
			"inout": "2--3 (2 \/ 3);  1"
		},
		{
			"source": "<strong>Z+<\/strong>",
			"in": "2",
			"out": "1",
			"description": "    <strong>conv2(..., 'same')<\/strong>. Converts inputs to <strong>double<\/strong>. See also <strong>Y+<\/strong> ",
			"brief": "two-dimensional convolution; maintains size",
			"inout": "2;  1"
		},
		{
			"source": "<strong>X,<\/strong>",
			"in": "1",
			"out": "1",
			"description": "    <strong>cos<\/strong> ",
			"brief": "cosine (radians)",
			"inout": "1;  1"
		},
		{
			"source": "<strong>Y,<\/strong>",
			"in": "1",
			"out": "1",
			"description": "    <strong>sin<\/strong> ",
			"brief": "sine (radians)",
			"inout": "1;  1"
		},
		{
			"source": "<strong>Z,<\/strong>",
			"in": "1",
			"out": "1",
			"description": "    <strong>tan<\/strong> ",
			"brief": "tangent (radians)",
			"inout": "1;  1"
		},
		{
			"source": "<strong>-<\/strong>",
			"in": "2",
			"out": "1",
			"description": "    <strong>-<\/strong> (<strong>minus<\/strong>), element-wise with singleton expansion ",
			"brief": "subtraction (element-wise, singleton expansion)",
			"inout": "2;  1"
		},
		{
			"source": "<strong>X-<\/strong>",
			"in": "2--4 (2 \/ 3)",
			"out": "1--2 (1)",
			"description": "    <strong>setdiff<\/strong>. Uses the <strong>'stable'<\/strong> flag by default. If one input is char \n    and the other is numeric, the latter is converted to char. This \n    function allows flag strings in third and subsequent inputs to \n    be replaced by numbers, as follows: 1: <strong>'rows'<\/strong>, 2: <strong>'stable'<\/strong>, 3: \n    <strong>'sorted'<\/strong> ",
			"brief": "set difference",
			"inout": "2--4 (2 \/ 3);  1--2 (1)"
		},
		{
			"source": "<strong>.<\/strong>",
			"in": null,
			"out": null,
			"description": "    <strong>break<\/strong> (control flow: loop). Terminate execution of innermost \n    loop. See also <strong>\"<\/strong>, <strong>`<\/strong>, <strong>X`<\/strong> ",
			"brief": "break",
			"inout": ";  "
		},
		{
			"source": "<strong>X.<\/strong>",
			"in": null,
			"out": null,
			"description": "    <strong>continue<\/strong> (control flow: loop). Pass control to next iteration of \n    innermost loop. See also <strong>\"<\/strong>, <strong>`<\/strong>, <strong>X`<\/strong> ",
			"brief": "continue",
			"inout": ";  "
		},
		{
			"source": "<strong>Y.<\/strong>",
			"in": "0--1 (1)",
			"out": "0",
			"description": "    <strong>pause<\/strong> (without outputs) ",
			"brief": "pause",
			"inout": "0--1 (1);  0"
		},
		{
			"source": "<strong>Z.<\/strong>",
			"in": "2--3 (2)",
			"out": "1",
			"description": "    <strong>bitget<\/strong>. If first input is <strong>char<\/strong> it is automatically converted to \n    <strong>double<\/strong> ",
			"brief": "get bit",
			"inout": "2--3 (2);  1"
		},
		{
			"source": "<strong>\/<\/strong>",
			"in": "2",
			"out": "1",
			"description": "    <strong>.\/<\/strong> (<strong>rdivide<\/strong>), element-wise with singleton expansion ",
			"brief": "array right division (element-wise, singleton expansion)",
			"inout": "2;  1"
		},
		{
			"source": "<strong>X\/<\/strong>",
			"in": "1",
			"out": "1",
			"description": "    <strong>angle<\/strong> ",
			"brief": "phase angle (radians)",
			"inout": "1;  1"
		},
		{
			"source": "<strong>Y\/<\/strong>",
			"in": "2",
			"out": "1",
			"description": "    right matrix division, <strong>\/<\/strong> (<strong>mrdivide<\/strong>) ",
			"brief": "right matrix division",
			"inout": "2;  1"
		},
		{
			"source": "<strong>Z\/<\/strong>",
			"in": "1--3 (1)",
			"out": "1",
			"description": "    <strong>unwrap<\/strong> ",
			"brief": "unwrap phase angle",
			"inout": "1--3 (1);  1"
		},
		{
			"source": "<strong>X0<\/strong>",
			"in": "1",
			"out": "1",
			"description": "    predefined literal depending on input. 1: <strong>'stable'<\/strong>, 2: <strong>'sorted'<\/strong>, \n    3: <strong>'rows'<\/strong>, 4: <strong>'last'<\/strong>, 5: <strong>'reverse'<\/strong>, 6: <strong>'descend'<\/strong>, 10: <strong>'first'<\/strong>, \n    11: <strong>'forward'<\/strong>, 12: <strong>'legacy'<\/strong>, 13: <strong>'ascend'<\/strong> ",
			"brief": "predefined literals",
			"inout": "1;  1"
		},
		{
			"source": "<strong>Y0<\/strong>",
			"in": "1",
			"out": "1",
			"description": "    predefined literal depending on input. 1: <strong>'Color'<\/strong>, 2: \n    <strong>'LineStyle'<\/strong>, 3: <strong>'LineWidth'<\/strong>, 4: <strong>'Marker'<\/strong>, 5: <strong>'MarkerSize'<\/strong>, 6: \n    <strong>'on'<\/strong>, 7: <strong>'off'<\/strong>, 8: <strong>'CDataMapping'<\/strong>, 9: <strong>'scaled'<\/strong>, 10: <strong>'manual'<\/strong>, \n    11: <strong>'tight'<\/strong>, 12: <strong>'fill'<\/strong>, 13: <strong>'ij'<\/strong>, 14: <strong>'xy'<\/strong>, 15: <strong>'equal'<\/strong>, 16: \n    <strong>'image'<\/strong>, 17: <strong>'normal'<\/strong>, 20: <strong>'auto'<\/strong>, 21: <strong>'LineJoin'<\/strong>, 22: <strong>'chamfer' \n    <\/strong>, 23: <strong>'miter'<\/strong>, 24: <strong>'round'<\/strong>, 25: <strong>'square'<\/strong>, 26: <strong>'diamond'<\/strong>, 27: \n    <strong>'pentagram'<\/strong>, 28: <strong>'hexagram'<\/strong>, 29: <strong>'visible'<\/strong>, 30: <strong>'Clipping'<\/strong>, 31: \n    <strong>'MarkerEdgeColor'<\/strong>, 32: <strong>'MarkerFaceColor'<\/strong>, 40: <strong>'direct'<\/strong>, 41: \n    <strong>'AlphaData'<\/strong>, 42: <strong>'AlphaDataMapping'<\/strong>, 43: <strong>'Cdata'<\/strong>, 44: <strong>'Xdata'<\/strong>, \n    45: <strong>'Ydata'<\/strong>, 46: <strong>'ZData'<\/strong>, 50: <strong>'autumn'<\/strong>, 51: <strong>'bone'<\/strong>, 52: \n    <strong>'colorcube'<\/strong>, 53: <strong>'cool'<\/strong>, 54: <strong>'copper'<\/strong>, 55: <strong>'flag'<\/strong>, 56: <strong>'gray'<\/strong>, \n    57: <strong>'hot'<\/strong>, 58: <strong>'hsv'<\/strong>, 59: <strong>'jet'<\/strong>, 60: <strong>'lines'<\/strong>, 61: <strong>'parula'<\/strong>, 62: \n    <strong>'pink'<\/strong>, 63: <strong>'prism'<\/strong>, 64: <strong>'spring'<\/strong>, 65: <strong>'summer'<\/strong>, 66: <strong>'winter'<\/strong> ",
			"brief": "predefined literals",
			"inout": "1;  1"
		},
		{
			"source": "<strong>X1<\/strong>",
			"in": "1",
			"out": "1",
			"description": "    predefined literal depending on input. 1: <strong>'bank'<\/strong>, 2: <strong>'compact'<\/strong>, \n    3: <strong>'hex'<\/strong>, 4: <strong>'short'<\/strong>, 5: <strong>'shortg'<\/strong>, 6: <strong>'long'<\/strong>, 7: <strong>'longg'<\/strong>, 8: \n    <strong>'loose'<\/strong>, 9: <strong>'rat'<\/strong>, 10: <strong>'longe'<\/strong>, 11: <strong>'longeng'<\/strong>, 12: <strong>'shorte'<\/strong>, 13: \n    <strong>'shorteng'<\/strong> ",
			"brief": "predefined literals",
			"inout": "1;  1"
		},
		{
			"source": "<strong>Y1<\/strong>",
			"in": "1",
			"out": "1",
			"description": "    predefined literal depending on input ",
			"brief": "predefined literals",
			"inout": "1;  1"
		},
		{
			"source": "<strong>X2<\/strong>",
			"in": "1",
			"out": "1",
			"description": "    predefined literal depending on input. 1: <strong>'double'<\/strong>, 2: <strong>'int8'<\/strong>, \n    3: <strong>'int64'<\/strong>, 4: <strong>'uint8'<\/strong>, 5: <strong>'uint64'<\/strong>, 6: <strong>'char'<\/strong>, 7: <strong>'logical'<\/strong>, 8: \n    <strong>'single'<\/strong>, 10: <strong>'int16'<\/strong>, 11: <strong>'int32'<\/strong>, 12: <strong>'uint16'<\/strong>, 13: <strong>'uint32'<\/strong>, \n    14: <strong>'like'<\/strong>, 15: <strong>'decimals'<\/strong>, 16: <strong>'includenan'<\/strong>, 17: <strong>'native'<\/strong>, 18: \n    <strong>'omitnan'<\/strong>, 19: <strong>'significant'<\/strong> ",
			"brief": "predefined literals",
			"inout": "1;  1"
		},
		{
			"source": "<strong>Y2<\/strong>",
			"in": "1",
			"out": "1",
			"description": "    predefined literal depending on input. 1: <strong>'A':'Z'<\/strong>, 2: <strong>'a':'z'<\/strong>, \n    3: <strong>['A':'Z' 'a':'z']<\/strong>, 4: <strong>'0':'9'<\/strong>, 5: <strong>['0':'9' 'A':'F']<\/strong>, 6: <strong>' \n    ':'~'<\/strong>, 11: <strong>'aeiou'<\/strong>, 12: <strong>'AEIOU'<\/strong>, 13: <strong>'aeiouAEIOU'<\/strong>, 20: <strong>['Mon'; \n    'Tue'; 'Wed'; 'Thu'; 'Fri'; 'Sat'; 'Sun']<\/strong>, 21: <strong>[298 302 288 305 \n    289 296 310]<\/strong> ",
			"brief": "predefined literals",
			"inout": "1;  1"
		},
		{
			"source": "<strong>X3<\/strong>",
			"in": "1",
			"out": "1",
			"description": "    predefined literal depending on input. 1: <strong>'start'<\/strong>, 2: <strong>'end'<\/strong>, 3: \n    <strong>'tokenExtents'<\/strong>, 4: <strong>'match'<\/strong>, 5: <strong>'tokens'<\/strong>, 6: <strong>'names'<\/strong>, 7: <strong>'split'<\/strong>, \n    8: <strong>'once'<\/strong>, 10: <strong>'ignorecase'<\/strong>, 11: <strong>'preservecase'<\/strong> ",
			"brief": "predefined literals",
			"inout": "1;  1"
		},
		{
			"source": "<strong>Y3<\/strong>",
			"in": "1",
			"out": "1",
			"description": "    predefined literal depending on input. 1: <strong>'magic'<\/strong>, 2: <strong>'hilb'<\/strong>, 3: \n    <strong>'invhilb'<\/strong>, 4: <strong>'hadamard'<\/strong>, 5: <strong>'pascal'<\/strong>, 6: <strong>'spiral'<\/strong>, 10: \n    <strong>'binomial'<\/strong>, 11: <strong>'cauchy'<\/strong>, 12: <strong>'chebspec'<\/strong>, 13: <strong>'chebvand'<\/strong>, 14: \n    <strong>'chow'<\/strong>, 15: <strong>'circul'<\/strong>, 16: <strong>'clement'<\/strong>, 17: <strong>'compar'<\/strong>, 18: <strong>'condex'<\/strong>, \n    19: <strong>'cycol'<\/strong>, 20: <strong>'dorr'<\/strong>, 21: <strong>'dramadah'<\/strong>, 22: <strong>'fiedler'<\/strong>, 23: \n    <strong>'forsythe'<\/strong>, 24: <strong>'frank'<\/strong>, 25: <strong>'gcdmat'<\/strong>, 26: <strong>'gearmat'<\/strong>, 27: \n    <strong>'grcar'<\/strong>, 28: <strong>'hanowa'<\/strong>, 29: <strong>'house'<\/strong>, 30: <strong>'integerdata'<\/strong>, 31: \n    <strong>'invhess'<\/strong>, 32: <strong>'invol'<\/strong>, 33: <strong>'ipjfact'<\/strong>, 34: <strong>'jordbloc'<\/strong>, 35: \n    <strong>'kahan'<\/strong>, 36: <strong>'kms'<\/strong>, 37: <strong>'krylov'<\/strong>, 38: <strong>'lauchli'<\/strong>, 39: <strong>'lehmer'<\/strong>, \n    40: <strong>'leslie'<\/strong>, 41: <strong>'lesp'<\/strong>, 42: <strong>'lotkin'<\/strong>, 43: <strong>'minij'<\/strong>, 44: \n    <strong>'moler'<\/strong>, 45: <strong>'neumann'<\/strong>, 46: <strong>'normaldata'<\/strong>, 47: <strong>'orthog'<\/strong>, 48: \n    <strong>'parter'<\/strong>, 49: <strong>'pei'<\/strong>, 50: <strong>'poisson'<\/strong>, 51: <strong>'prolate'<\/strong>, 52: <strong>'qmult'<\/strong>, \n    53: <strong>'randcolu'<\/strong>, 54: <strong>'randcorr'<\/strong>, 55: <strong>'randhess'<\/strong>, 56: <strong>'randjorth'<\/strong>, \n    57: <strong>'rando'<\/strong>, 58: <strong>'randsvd'<\/strong>, 59: <strong>'redheff'<\/strong>, 60: <strong>'riemann'<\/strong>, 61: \n    <strong>'ris'<\/strong>, 62: <strong>'sampling'<\/strong>, 63: <strong>'smoke'<\/strong>, 64: <strong>'toeppd'<\/strong>, 65: <strong>'toeppen'<\/strong>, \n    66: <strong>'tridiag'<\/strong>, 67: <strong>'triw'<\/strong>, 68: <strong>'uniformdata'<\/strong>, 69: <strong>'wathen'<\/strong>, 70: \n    <strong>'wilk'<\/strong> ",
			"brief": "predefined literals",
			"inout": "1;  1"
		},
		{
			"source": "<strong>X4<\/strong>",
			"in": "1",
			"out": "1",
			"description": "    predefined literal depending on input. 1: <strong>'CollapseDelimiters'<\/strong>, \n    2: <strong>'DelimiterType'<\/strong>, 3: <strong>'RegularExpression'<\/strong>, 4: <strong>'center'<\/strong>, 5: \n    <strong>'left'<\/strong>, 6: <strong>'local'<\/strong>, 10: <strong>'right'<\/strong>, 11: <strong>'simple'<\/strong> ",
			"brief": "predefined literals",
			"inout": "1;  1"
		},
		{
			"source": "<strong>Y4<\/strong>",
			"in": "1",
			"out": "1",
			"description": "    predefined literal depending on input. 1: <strong>'\\d+'<\/strong>, 2: \n    <strong>'[+-]?\\d+(\\.\\d*)?'<\/strong>, 3: <strong>'[A-Za-z]+'<\/strong>, 4: <strong>'[A-Za-z\\-]+'<\/strong>, 5: \n    <strong>'[A-Za-z\\-\\d]+'<\/strong> ",
			"brief": "predefined literals",
			"inout": "1;  1"
		},
		{
			"source": "<strong>X5<\/strong>",
			"in": "1",
			"out": "1",
			"description": "    predefined literal depending on input. 1: <strong>'full'<\/strong>, 2: <strong>'same'<\/strong>, 3: \n    <strong>'valid'<\/strong>, 6: <strong>'linear'<\/strong>, 7: <strong>'nearest'<\/strong>, 8: <strong>'next'<\/strong>, 9: <strong>'previous'<\/strong>, \n    10: <strong>'spline'<\/strong>, 11: <strong>'pchip'<\/strong>, 12: <strong>'cubic'<\/strong>, 13: <strong>'v5cubic'<\/strong>, 14: \n    <strong>'extrap'<\/strong>, 20: <strong>'distinct'<\/strong>, 21: <strong>'sliding'<\/strong>, 22: <strong>'indexed'<\/strong> ",
			"brief": "predefined literals",
			"inout": "1;  1"
		},
		{
			"source": "<strong>Y5<\/strong>",
			"in": "1",
			"out": "1",
			"description": "    predefined literal depending on input. 1: <strong>'circular'<\/strong>, 2: \n    <strong>'replicate'<\/strong>, 3: <strong>'symmetric'<\/strong>, 4: <strong>'pre'<\/strong>, 5: <strong>'post'<\/strong>, 6: <strong>'both'<\/strong> ",
			"brief": "predefined literals",
			"inout": "1;  1"
		},
		{
			"source": "<strong>X6<\/strong>",
			"in": "1",
			"out": "1",
			"description": "    predefined literal depending on input. 1: <strong>'get'<\/strong>, 2: <strong>'post'<\/strong>, 3: \n    <strong>'Timeout'<\/strong>, 4: <strong>'png'<\/strong>, 5: <strong>'ppm'<\/strong>, 6: <strong>'gif'<\/strong>, 7: <strong>'bmp'<\/strong>, 9: <strong>'none'<\/strong>, \n    11: <strong>'Frames'<\/strong>, 12: <strong>'BackgroundColor'<\/strong>, 13: <strong>'Index'<\/strong>, 14: <strong>'Info'<\/strong>, \n    15: <strong>'ReductionLevel'<\/strong>, 16: <strong>'PixelRegion'<\/strong>, 17: <strong>'V79Compatible'<\/strong>, \n    20: <strong>'Border'<\/strong>, 21: <strong>'Colormap'<\/strong>, 22: <strong>'DisplayRange'<\/strong>, 23: \n    <strong>'InitialMagnification'<\/strong>, 24: <strong>'Parent'<\/strong>, 25: <strong>'Reduce'<\/strong> ",
			"brief": "predefined literals",
			"inout": "1;  1"
		},
		{
			"source": "<strong>Y6<\/strong>",
			"in": "1",
			"out": "1",
			"description": "    predefined literal depending on input. 1: <strong>[false true false; \n    true false true; false true false]<\/strong>, 2: <strong>[false true false; true \n    true true; false true false]<\/strong>, 3: <strong>[true true true; true false \n    true; true true true]<\/strong>, 4: <strong>[true true true; true true true; true \n    true true]<\/strong>, 5: <strong>[true true; true true]<\/strong>, 6: <strong>[false false false; \n    false true false; false false false]<\/strong> ",
			"brief": "predefined literals",
			"inout": "1;  1"
		},
		{
			"source": "<strong>X7<\/strong>",
			"in": "1",
			"out": "1",
			"description": "    predefined literal depending on input. 1: <strong>'BinWidth'<\/strong>, 2: \n    <strong>'BinLimits'<\/strong>, 3: <strong>'Normalization'<\/strong>, 4: <strong>'count'<\/strong>, 5: <strong>'probability'<\/strong>, \n    6: <strong>'countdensity'<\/strong>, 7: <strong>'pdf'<\/strong>, 8: <strong>'cumcount'<\/strong>, 9: <strong>'cdf'<\/strong>, 10: \n    <strong>'BinMethod'<\/strong>, 11: <strong>'auto'<\/strong>, 12: <strong>'scott'<\/strong>, 13: <strong>'fd'<\/strong>, 14: <strong>'integers'<\/strong>, \n    15: <strong>'sturges'<\/strong>, 16: <strong>'sqrt'<\/strong> ",
			"brief": "predefined literals",
			"inout": "1;  1"
		},
		{
			"source": "<strong>X8<\/strong>",
			"in": "1",
			"out": "1",
			"description": "    predefined literal depending on input. 1: <strong>'cityblock'<\/strong>, 2: \n    <strong>'minkowski'<\/strong>, 3: <strong>'chebychev'<\/strong>, 4: <strong>'cosine'<\/strong>, 5: <strong>'correlation'<\/strong>, 6: \n    <strong>'hamming'<\/strong>, 10: <strong>'euclidean'<\/strong>, 11: <strong>'seuclidean'<\/strong>, 12: <strong>'mahalanobis'<\/strong>, \n    13: <strong>'spearman'<\/strong>, 14: <strong>'jaccard'<\/strong>, 15: <strong>'fro'<\/strong>, 16: <strong>'Smallest'<\/strong>, 17: \n    <strong>'Largest'<\/strong> ",
			"brief": "predefined literals",
			"inout": "1;  1"
		},
		{
			"source": "<strong>X9<\/strong>",
			"in": "1",
			"out": "1",
			"description": "    predefined literal depending on input. 1: <strong>'%.15g '<\/strong>, 10: <strong>'seed'<\/strong> ",
			"brief": "predefined literals",
			"inout": "1;  1"
		},
		{
			"source": "<strong>:<\/strong>",
			"in": "1--3 (1 \/ 2)",
			"out": "1",
			"description": "    <strong>colon<\/strong> (with three inputs <strong>x<\/strong>, <strong>y<\/strong>, <strong>z<\/strong> produces <strong>x:y:z<\/strong>; with two inputs \n    <strong>x<\/strong>, <strong>y<\/strong> produces <strong>x:y<\/strong>). If one input: produces <strong>1:x<\/strong> ",
			"brief": "vector of equally spaced values",
			"inout": "1--3 (1 \/ 2);  1"
		},
		{
			"source": "<strong>X:<\/strong>",
			"in": "1",
			"out": "1",
			"description": "    linearize to column array (index with <strong>(:)<\/strong>) ",
			"brief": "linearize to column array",
			"inout": "1;  1"
		},
		{
			"source": "<strong>Y:<\/strong>",
			"in": "1",
			"out": "0-- (number of elements of first input)",
			"description": "    generate comma-separated list from cell array (index with <strong>{:}<\/strong>) \n    and push each element onto stack ",
			"brief": "unbox cell array",
			"inout": "1;  0-- (number of elements of first input)"
		},
		{
			"source": "<strong>Z:<\/strong>",
			"in": "2--4 (3)",
			"out": "1",
			"description": "    <strong>bitset<\/strong>. If first input is <strong>char<\/strong> it is automatically converted to \n    <strong>double<\/strong> ",
			"brief": "set bit",
			"inout": "2--4 (3);  1"
		},
		{
			"source": "<strong>X;<\/strong>",
			"in": "1",
			"out": "1",
			"description": "    <strong>acos<\/strong> ",
			"brief": "inverse cosine (radians)",
			"inout": "1;  1"
		},
		{
			"source": "<strong>Y;<\/strong>",
			"in": "1",
			"out": "1",
			"description": "    <strong>asin<\/strong> ",
			"brief": "inverse sine (radians)",
			"inout": "1;  1"
		},
		{
			"source": "<strong>Z;<\/strong>",
			"in": "2",
			"out": "1",
			"description": "    <strong>atan2<\/strong>, element-wise with singleton expansion ",
			"brief": "four quadrant inverse tangent (radians; element-wise, singleton expansion)",
			"inout": "2;  1"
		},
		{
			"source": "<strong><<\/strong>",
			"in": "2",
			"out": "1",
			"description": "    <strong><<\/strong> (<strong>lt<\/strong>), element-wise with singleton expansion ",
			"brief": "is less than? (element-wise, singleton expansion)",
			"inout": "2;  1"
		},
		{
			"source": "<strong>X<<\/strong>",
			"in": "1--3 (1)",
			"out": "1--2 (1 \/ second)",
			"description": "    <strong>min<\/strong>. If 2 inputs: element-wise with singleton expansion ",
			"brief": "minimum",
			"inout": "1--3 (1);  1--2 (1 \/ second)"
		},
		{
			"source": "<strong>Y<<\/strong>",
			"in": "1--3 (1 \/ 2)",
			"out": "1",
			"description": "    <strong>cummin<\/strong> ",
			"brief": "cumulative minimum",
			"inout": "1--3 (1 \/ 2);  1"
		},
		{
			"source": "<strong>=<\/strong>",
			"in": "2",
			"out": "1",
			"description": "    <strong>==<\/strong> (<strong>eq<\/strong>), element-wise with singleton expansion ",
			"brief": "is equal? (element-wise, singleton expansion)",
			"inout": "2;  1"
		},
		{
			"source": "<strong>X=<\/strong>",
			"in": "2-- (2)",
			"out": "1",
			"description": "    <strong>isequal<\/strong> ",
			"brief": "true if arrays are numerically equal",
			"inout": "2-- (2);  1"
		},
		{
			"source": "<strong>Y=<\/strong>",
			"in": "2",
			"out": "1",
			"description": "    <strong>strcmp<\/strong>. If first or second inputs are numeric they are converted \n    to char ",
			"brief": "compare strings",
			"inout": "2;  1"
		},
		{
			"source": "<strong>Z=<\/strong>",
			"in": "3",
			"out": "1",
			"description": "    <strong>strncmp<\/strong>. If first or second inputs are numeric they are \n    converted to char ",
			"brief": "compare first characters of strings",
			"inout": "3;  1"
		},
		{
			"source": "<strong>><\/strong>",
			"in": "2",
			"out": "1",
			"description": "    <strong>><\/strong> (<strong>gt<\/strong>), element-wise with singleton expansion ",
			"brief": "is greater than? (element-wise, singleton expansion)",
			"inout": "2;  1"
		},
		{
			"source": "<strong>X><\/strong>",
			"in": "1--3 (1)",
			"out": "1--2 (1 \/ second)",
			"description": "    <strong>max<\/strong>. If 2 inputs: element-wise with singleton expansion ",
			"brief": "maximum",
			"inout": "1--3 (1);  1--2 (1 \/ second)"
		},
		{
			"source": "<strong>Y><\/strong>",
			"in": "1--3 (1 \/ 2)",
			"out": "1",
			"description": "    <strong>cummax<\/strong> ",
			"brief": "cumulative maximum",
			"inout": "1--3 (1 \/ 2);  1"
		},
		{
			"source": "<strong>?<\/strong>",
			"in": null,
			"out": null,
			"description": "    <strong>if<\/strong> (control flow: conditional branch). See also <strong>]<\/strong>, <strong>}<\/strong> ",
			"brief": "if",
			"inout": ";  "
		},
		{
			"source": "<strong>Y?<\/strong>",
			"in": "0",
			"out": "1",
			"description": "    answer why. Sort of ",
			"brief": "answer why",
			"inout": "0;  1"
		},
		{
			"source": "<strong>Z?<\/strong>",
			"in": "1--6 (3)",
			"out": "1",
			"description": "    <strong>sparse<\/strong> ",
			"brief": "create sparse matrix",
			"inout": "1--6 (3);  1"
		},
		{
			"source": "<strong>@<\/strong>",
			"in": null,
			"out": null,
			"description": "    for loop variable, do...while loop iteration index or while loop \n    iteration index of innermost loop. See also <strong>X@<\/strong> ",
			"brief": "for loop variable or do...while \/ while loop iteration index",
			"inout": ";  "
		},
		{
			"source": "<strong>X@<\/strong>",
			"in": null,
			"out": null,
			"description": "    for loop iteration index of innermost loop. See also <strong>@<\/strong> ",
			"brief": "for loop iteration index",
			"inout": ";  "
		},
		{
			"source": "<strong>Y@<\/strong>",
			"in": "1--2 (1 \/ 2)",
			"out": "1",
			"description": "    If 1 input: <strong>perms<\/strong>. If 2 inputs: variations (without repetition). \n    In either case, the results are sorted ",
			"brief": "all possible permutations \/ variations",
			"inout": "1--2 (1 \/ 2);  1"
		},
		{
			"source": "<strong>Z@<\/strong>",
			"in": "1--3 (1 \/ 2)",
			"out": "1",
			"description": "    <strong>randperm<\/strong> (produces a row vector as output). If 3 inputs: third \n    input indicates number of permutations, each on a different row. ",
			"brief": "random permutation",
			"inout": "1--3 (1 \/ 2);  1"
		},
		{
			"source": "<strong>A<\/strong>",
			"in": "1--2 (1 \/ 2)",
			"out": "1",
			"description": "    <strong>all<\/strong>. See also <strong>XA<\/strong> ",
			"brief": "all",
			"inout": "1--2 (1 \/ 2);  1"
		},
		{
			"source": "<strong>XA<\/strong>",
			"in": "1",
			"out": "1",
			"description": "    <strong>all(..., 1)<\/strong>. See also <strong>A<\/strong> ",
			"brief": "all, along first dimension",
			"inout": "1;  1"
		},
		{
			"source": "<strong>YA<\/strong>",
			"in": "2--3 (2 \/ 3)",
			"out": "1",
			"description": "    (i) <strong>dec2base<\/strong>. (ii) If second input has more than one element: it \n    defines the symbols, which can be characters or numbers. The \n    number of symbols defines the base, which can exceed 36 ",
			"brief": "convert integer to string representation in given base",
			"inout": "2--3 (2 \/ 3);  1"
		},
		{
			"source": "<strong>ZA<\/strong>",
			"in": "2",
			"out": "1",
			"description": "    (i) <strong>base2dec<\/strong>. (ii) If second input has more than one element: it \n    defines the symbols, which can be characters (case-sensitive) or \n    numbers. The number of symbols defines the base, which can \n    exceed 36. In (i) and (ii), non-recognized digits are ignored ",
			"brief": "convert string in given base to decimal integer",
			"inout": "2;  1"
		},
		{
			"source": "<strong>B<\/strong>",
			"in": "1--2 (1 \/ 2)",
			"out": "1",
			"description": "    <strong>logical(dec2bin(...)-'0')<\/strong>. See also <strong>YB<\/strong> ",
			"brief": "convert from decimal to binary. Produces a logical vector",
			"inout": "1--2 (1 \/ 2);  1"
		},
		{
			"source": "<strong>XB<\/strong>",
			"in": "1",
			"out": "1",
			"description": "    <strong>bin2dec(char(logical(...)+'0'))<\/strong>. Works also for cell array \n    input. See also <strong>ZB<\/strong> ",
			"brief": "convert from binary to decimal",
			"inout": "1;  1"
		},
		{
			"source": "<strong>YB<\/strong>",
			"in": "1--2 (1 \/ 2)",
			"out": "1",
			"description": "    <strong>dec2bin<\/strong>. See also <strong>B<\/strong> ",
			"brief": "convert decimal number to binary string",
			"inout": "1--2 (1 \/ 2);  1"
		},
		{
			"source": "<strong>ZB<\/strong>",
			"in": "1",
			"out": "1",
			"description": "    <strong>bin2dec<\/strong>. See also <strong>XB<\/strong> ",
			"brief": "convert binary string to decimal number",
			"inout": "1;  1"
		},
		{
			"source": "<strong>XC<\/strong>",
			"in": "1--7 (2)",
			"out": "1--3 (1)",
			"description": "    <strong>histcounts<\/strong> ",
			"brief": "histogram bin counts",
			"inout": "1--7 (2);  1--3 (1)"
		},
		{
			"source": "<strong>YC<\/strong>",
			"in": "2--4 (2)",
			"out": "1",
			"description": "    <strong>im2col<\/strong>. If the second input is a scalar <strong>n<\/strong>, it is transformed \n    into <strong>[1 n]<\/strong> if the first input is a row vector, or to <strong>[n 1]<\/strong> \n    otherwise. See also <strong>ZC<\/strong> ",
			"brief": "rearrange array blocks into columns",
			"inout": "2--4 (2);  1"
		},
		{
			"source": "<strong>ZC<\/strong>",
			"in": "2--3 (2)",
			"out": "1",
			"description": "    <strong>im2col(..., 'distinct')<\/strong>. If the second input is a scalar n, it \n    is transformed into [1 n] if the first input is a row vector, or \n    to [n 1] otherwise. See also <strong>YC<\/strong> ",
			"brief": "rearrange distinct array blocks into columns",
			"inout": "2--3 (2);  1"
		},
		{
			"source": "<strong>D<\/strong>",
			"in": "0-- (1 \/ number of elements in stack)",
			"out": "0",
			"description": "    If 1 input: <strong>disp(num2str(..., '%.15g '))<\/strong>. If several inputs: \n    <strong>disp(num2str(eachInput,lastInput))<\/strong>, where <strong>eachInput<\/strong> loops over \n    all inputs but the last. In either case, (nested) cell arrays \n    are (recursively) unboxed in linear order. See also <strong>XD<\/strong>, <strong>YD<\/strong>, <strong>ZD<\/strong> ",
			"brief": "convert to string and display",
			"inout": "0-- (1 \/ number of elements in stack);  0"
		},
		{
			"source": "<strong>XD<\/strong>",
			"in": "0-- (number of elements in stack \/ 1)",
			"out": "0",
			"description": "    <strong>disp(num2str(eachInput, '%.15g '))<\/strong>, where <strong>eachInput<\/strong> loops over \n    all inputs. (Nested) cell arrays are (recursively) unboxed in \n    linear order. See also <strong>D<\/strong>, <strong>YD<\/strong>, <strong>ZD<\/strong> ",
			"brief": "convert to string and display",
			"inout": "0-- (number of elements in stack \/ 1);  0"
		},
		{
			"source": "<strong>YD<\/strong>",
			"in": "1-- (2)",
			"out": "0--2 (1)",
			"description": "    <strong>sprintf<\/strong>. If 0 outputs: prints to screen using <strong>fprintf(...)<\/strong>. See \n    also <strong>D<\/strong>, <strong>XD<\/strong>, <strong>ZD<\/strong> ",
			"brief": "write formatted data to string",
			"inout": "1-- (2);  0--2 (1)"
		},
		{
			"source": "<strong>ZD<\/strong>",
			"in": "0-- (1)",
			"out": "0",
			"description": "    <strong>disp<\/strong> for each input. See also <strong>D<\/strong>, <strong>XD<\/strong>, <strong>YD<\/strong> ",
			"brief": "display",
			"inout": "0-- (1);  0"
		},
		{
			"source": "<strong>E<\/strong>",
			"in": "1",
			"out": "1",
			"description": "    <strong>(...)*2<\/strong> ",
			"brief": "multiply by 2",
			"inout": "1;  1"
		},
		{
			"source": "<strong>XE<\/strong>",
			"in": "3",
			"out": "1",
			"description": "    With numeric or char inputs, replace in first input all \n    occurrences of each element of the second input by the \n    corresponding element of the third input. The third input may be \n    longer than the second, and then the extra elements are ignored. \n    Output has the same class and size as the first input. If the \n    three inputs are cell arrays of strings (the second may also be \n    a string instead of a cell array of strings), each string of the \n    first input is considered atomic, that is, replacing is based on \n    whole strings. If the first input is a cell array and the others \n    are numeric or char, replacing is done on each cell's contents \n    as if the cell's contents were the first input ",
			"brief": "replace elements in numeric or char array",
			"inout": "3;  1"
		},
		{
			"source": "<strong>G<\/strong>",
			"in": "0--1 (0 if clipboard currently has 0 or 1 levels, 1 otherwise \/ 0)",
			"out": "0-- (number of levels addressed according to input specification)",
			"description": "    paste from user-input clipboard G. If 0 input arguments: \n    addresses all levels. If 1 input argument: addresses specified \n    level. In either of those cases, if clipboard G has no levels \n    one user-input is implicitly taken to fill the first level ",
			"brief": "paste from user-input clipboard G",
			"inout": "0--1 (0 if clipboard currently has 0 or 1 levels, 1 otherwise \/ 0);  0-- (number of levels addressed according to input specification)"
		},
		{
			"source": "<strong>XG<\/strong>",
			"in": "1-- (1 \/ 2)",
			"out": "0",
			"description": "    <strong>plot<\/strong>. Calls <strong>drawnow<\/strong> to update figure immediately ",
			"brief": "plot",
			"inout": "1-- (1 \/ 2);  0"
		},
		{
			"source": "<strong>YG<\/strong>",
			"in": "2-- (2 \/ 3)",
			"out": "0",
			"description": "    <strong>imwrite<\/strong>, <strong>imagesc<\/strong>, <strong>image<\/strong> or <strong>imshow<\/strong>. If last input is a scalar: <strong>0<\/strong> \n    corresponds to <strong>imwrite<\/strong>, <strong>1<\/strong> to <strong>imagesc<\/strong>, <strong>2<\/strong> to <strong>image<\/strong> and <strong>3<\/strong> to \n    <strong>imshow<\/strong>. The corresponding function is called with the remaining \n    inputs. If last input is numeric and not a scalar: <strong>imshow<\/strong> is \n    called with all inputs. If last input is char: <strong>imwrite<\/strong> is called \n    with all inputs. For <strong>imwrite<\/strong>, if the filename has no extension \n    '.png' is added. For <strong>imagesc<\/strong> and <strong>image<\/strong>, the function call is \n    followed by <strong>axis ij, axis image<\/strong>. For <strong>imagesc<\/strong>, <strong>image<\/strong> and <strong>imwhow<\/strong>, \n    <strong>drawnow<\/strong> is called to update figure immediately ",
			"brief": "display or save image",
			"inout": "2-- (2 \/ 3);  0"
		},
		{
			"source": "<strong>ZG<\/strong>",
			"in": "1-- (2 \/ 3)",
			"out": "0--1 (0)",
			"description": "    Depending on numeric last input, calls a graphic function or \n    <strong>format<\/strong> with the remaining inputs.  0: <strong>format<\/strong>.  1: <strong>axis<\/strong>.  2: \n    <strong>colormap<\/strong>. With 0 outputs, calls <strong>drawnow<\/strong> to update figure \n    immediately.  3: <strong>hold<\/strong> ",
			"brief": "control appearance of graphics \/ format",
			"inout": "1-- (2 \/ 3);  0--1 (0)"
		},
		{
			"source": "<strong>H<\/strong>",
			"in": "0",
			"out": "0-- (number of elements in clipboard)",
			"description": "    paste from clipboard H ",
			"brief": "paste from clipboard H",
			"inout": "0;  0-- (number of elements in clipboard)"
		},
		{
			"source": "<strong>XH<\/strong>",
			"in": "0-- (1 \/ 2)",
			"out": "0",
			"description": "    copy to clipboard H ",
			"brief": "copy to clipboard H",
			"inout": "0-- (1 \/ 2);  0"
		},
		{
			"source": "<strong>I<\/strong>",
			"in": "0",
			"out": "0-- (number of elements in clipboard)",
			"description": "    paste from clipboard I ",
			"brief": "paste from clipboard I",
			"inout": "0;  0-- (number of elements in clipboard)"
		},
		{
			"source": "<strong>XI<\/strong>",
			"in": "0-- (1)",
			"out": "0",
			"description": "    copy to clipboard I ",
			"brief": "copy to clipboard I",
			"inout": "0-- (1);  0"
		},
		{
			"source": "<strong>YI<\/strong>",
			"in": "3--4 (3 \/ 4)",
			"out": "1",
			"description": "    <strong>col2im<\/strong>. Uses <strong>'distinct'<\/strong> option by default. Second and third \n    inputs may be scalars, and then they are interpreted as numbers \n    of columns. Third input may be a two-vector with product less \n    then the number of elements of first input, and then it is \n    appropriately scaled. This function allows flag strings in \n    fourth input to be replaced by numbers, as follows: 1: \n    <strong>'distinct'<\/strong>, 2: <strong>'sliding'<\/strong> ",
			"brief": "rearrange matrix columns into blocks",
			"inout": "3--4 (3 \/ 4);  1"
		},
		{
			"source": "<strong>J<\/strong>",
			"in": "0",
			"out": "0-- (number of elements in clipboard)",
			"description": "    paste from clipboard J ",
			"brief": "paste from clipboard J",
			"inout": "0;  0-- (number of elements in clipboard)"
		},
		{
			"source": "<strong>XJ<\/strong>",
			"in": "0-- (1)",
			"out": "0",
			"description": "    copy to clipboard J ",
			"brief": "copy to clipboard J",
			"inout": "0-- (1);  0"
		},
		{
			"source": "<strong>K<\/strong>",
			"in": "0",
			"out": "0-- (number of elements in clipboard)",
			"description": "    paste from clipboard K ",
			"brief": "paste from clipboard K",
			"inout": "0;  0-- (number of elements in clipboard)"
		},
		{
			"source": "<strong>XK<\/strong>",
			"in": "0-- (1)",
			"out": "0",
			"description": "    copy to clipboard K ",
			"brief": "copy to clipboard K",
			"inout": "0-- (1);  0"
		},
		{
			"source": "<strong>L<\/strong>",
			"in": "1",
			"out": "0-- (number of elements in clipboard level)",
			"description": "    paste from multi-level clipboard L. Input specifies level ",
			"brief": "paste from multi-level clipboard L",
			"inout": "1;  0-- (number of elements in clipboard level)"
		},
		{
			"source": "<strong>XL<\/strong>",
			"in": "1-- (2 \/ 3)",
			"out": "0",
			"description": "    copy to multi-level clipboard L. Topmost input specifies level ",
			"brief": "copy to multi-level clipboard L",
			"inout": "1-- (2 \/ 3);  0"
		},
		{
			"source": "<strong>YL<\/strong>",
			"in": "1-- (2 \/ 3)",
			"out": "1-- (1)",
			"description": "    <strong>gallery<\/strong> with matrix name as last input. Also includes <strong>magic<\/strong>, \n    <strong>hilb<\/strong>, <strong>invhilb<\/strong>, <strong>hadamard<\/strong>, <strong>pascal<\/strong>, <strong>spiral<\/strong>. This function allows \n    some strings in last input to be replaced by numbers, as \n    follows:  1: <strong>'spiral'<\/strong>, 2: <strong>'pascal'<\/strong>, 3: <strong>'magic'<\/strong>, 4: <strong>'hadamard'<\/strong>, \n    5: <strong>'circul'<\/strong>, 6: <strong>'gcdmat'<\/strong>, 7: <strong>'minij'<\/strong>, 8: <strong>'hilb'<\/strong>, 9: <strong>'invhilb'<\/strong>, \n    10: <strong>'tridiag'<\/strong>, 11: <strong>'ris'<\/strong> ",
			"brief": "Higham test matrices and other matrices",
			"inout": "1-- (2 \/ 3);  1-- (1)"
		},
		{
			"source": "<strong>M<\/strong>",
			"in": "1",
			"out": "0-- (1 or number of elements in clipboard level)",
			"description": "    paste from function-input clipboard M. Input specifies level (1 \n    to 4) or individual input (5 or larger) ",
			"brief": "paste from function-input clipboard M",
			"inout": "1;  0-- (1 or number of elements in clipboard level)"
		},
		{
			"source": "<strong>XM<\/strong>",
			"in": "1--2 (1)",
			"out": "1--3 (1)",
			"description": "    <strong>mode<\/strong>. First input can be a cell array of strings ",
			"brief": "mode (most frequent value)",
			"inout": "1--2 (1);  1--3 (1)"
		},
		{
			"source": "<strong>N<\/strong>",
			"in": "0",
			"out": "1",
			"description": "    number of elements in the stack ",
			"brief": "number of elements in the stack",
			"inout": "0;  1"
		},
		{
			"source": "<strong>XN<\/strong>",
			"in": "2",
			"out": "1",
			"description": "    <strong>nchoosek<\/strong>. This interprets first input as an array (even if it is \n    a single number). For inputs <strong>x<\/strong> and <strong>k<\/strong>, if <strong>x<\/strong> has less than <strong>k<\/strong> \n    elements or if <strong>k<\/strong> is non-positive the result is an empty array. \n    See also <strong>Xn<\/strong> ",
			"brief": "all combinations",
			"inout": "2;  1"
		},
		{
			"source": "<strong>YN<\/strong>",
			"in": "0-- (0)",
			"out": "1",
			"description": "    <strong>NaN<\/strong> function. If 0 inputs: produces literal <strong>NaN<\/strong>. ",
			"brief": "not-a-number",
			"inout": "0-- (0);  1"
		},
		{
			"source": "<strong>ZN<\/strong>",
			"in": "1",
			"out": "1",
			"description": "    <strong>isnan<\/strong> ",
			"brief": "true for not-a-number",
			"inout": "1;  1"
		},
		{
			"source": "<strong>O<\/strong>",
			"in": "0-- (0 \/ 2)",
			"out": "1",
			"description": "    <strong>zeros<\/strong> (if 0 inputs: produces output 0) ",
			"brief": "array of zeros",
			"inout": "0-- (0 \/ 2);  1"
		},
		{
			"source": "<strong>XO<\/strong>",
			"in": "1--4 (2)",
			"out": "1",
			"description": "    <strong>datestr<\/strong> ",
			"brief": "string representation of date",
			"inout": "1--4 (2);  1"
		},
		{
			"source": "<strong>YO<\/strong>",
			"in": "1--6 (1)",
			"out": "1",
			"description": "    <strong>datenum<\/strong> ",
			"brief": "serial date number",
			"inout": "1--6 (1);  1"
		},
		{
			"source": "<strong>ZO<\/strong>",
			"in": "1--3 (2)",
			"out": "1--6 (1)",
			"description": "    <strong>datevec<\/strong> ",
			"brief": "date components",
			"inout": "1--3 (2);  1--6 (1)"
		},
		{
			"source": "<strong>P<\/strong>",
			"in": "1--2 (1 \/ 2)",
			"out": "1",
			"description": "    <strong>flip<\/strong>. See also <strong>XP<\/strong> ",
			"brief": "flip the order of elements",
			"inout": "1--2 (1 \/ 2);  1"
		},
		{
			"source": "<strong>XP<\/strong>",
			"in": "1",
			"out": "1",
			"description": "    <strong>flipud<\/strong>. See also <strong>P<\/strong> ",
			"brief": "flip array in up-down direction",
			"inout": "1;  1"
		},
		{
			"source": "<strong>YP<\/strong>",
			"in": "0",
			"out": "1",
			"description": "    <strong>pi<\/strong> ",
			"brief": "pi",
			"inout": "0;  1"
		},
		{
			"source": "<strong>ZP<\/strong>",
			"in": "2--5 (2 \/ 3)",
			"out": "1--2 (1)",
			"description": "    <strong>pdist2<\/strong>. Only predefined distance functions are allowed. This \n    function allows flag strings in the third input to be replaced \n    by numbers, as follows:  1: <strong>'cityblock'<\/strong>, 2: <strong>'hamming'<\/strong>, 3: \n    <strong>'chebychev'<\/strong>, 4: <strong>'correlation'<\/strong>, 5: <strong>'cosine'<\/strong>, 6: <strong>'seuclidean'<\/strong>, 7: \n    <strong>'minkowski'<\/strong>, 8: <strong>'mahalanobis'<\/strong>, 9: <strong>'spearman'<\/strong>, 10: <strong>'jaccard'<\/strong>, 11: \n    <strong>'euclidean'<\/strong> ",
			"brief": "pairwise distances between two sets of points",
			"inout": "2--5 (2 \/ 3);  1--2 (1)"
		},
		{
			"source": "<strong>Q<\/strong>",
			"in": "1",
			"out": "1",
			"description": "    <strong>(...)+1<\/strong> ",
			"brief": "increment by 1",
			"inout": "1;  1"
		},
		{
			"source": "<strong>XQ<\/strong>",
			"in": "2--6 (3)",
			"out": "1",
			"description": "    <strong>accumarray<\/strong>. The third output may be omitted, and then it is \n    interpreted as <strong>[]<\/strong>. Fourth\/third argument specifies an anonymous \n    function, as follows:  1: <strong>'@sum'<\/strong>, 2: <strong>'@mean'<\/strong>, 3: \n    <strong>'@(x){sort(x).'}'<\/strong>, 4: <strong>'@max'<\/strong>, 5: <strong>'@min'<\/strong>, 6: <strong>'@prod'<\/strong>, 7: \n    <strong>'@(x){x.'}'<\/strong>, 8: <strong>'@(x){x}'<\/strong>, 9: <strong>'@(x){sort(x)}'<\/strong>, 10: <strong>'@(x)x(1)'<\/strong>, \n    11: <strong>'@(x)x(end)'<\/strong>, 12: <strong>'@(x){cumsum(x).'}'<\/strong>, 13: \n    <strong>'@(x){cumprod(x)}'<\/strong>, 14: <strong>'@nansum'<\/strong>, 15: <strong>'@nanmean'<\/strong>, 16: \n    <strong>'@nanmax'<\/strong>, 17: <strong>'@nanmin'<\/strong>, 18: <strong>'@(x){cummax(x).'}'<\/strong>, 19: \n    <strong>'@(x){cummin(x)}'<\/strong>, 20: <strong>'@(x){cummax(x).'}'<\/strong>, 21: \n    <strong>'@(x){cummin(x)}'<\/strong> ",
			"brief": "construct array by accumulation",
			"inout": "2--6 (3);  1"
		},
		{
			"source": "<strong>ZQ<\/strong>",
			"in": "1--3 (2 \/ 1)",
			"out": "1",
			"description": "    (i) If 1 input: <strong>roots<\/strong>. (ii) If 2 inputs: <strong>polyval<\/strong>. If 3 inputs: \n    <strong>polyfit<\/strong> ",
			"brief": "polynomial roots \/ evaluate polynomial \/ fit polynomial",
			"inout": "1--3 (2 \/ 1);  1"
		},
		{
			"source": "<strong>R<\/strong>",
			"in": "1--2 (1 \/ 2)",
			"out": "1",
			"description": "    <strong>triu<\/strong>. See also <strong>XR<\/strong>. ",
			"brief": "upper triangular part",
			"inout": "1--2 (1 \/ 2);  1"
		},
		{
			"source": "<strong>XR<\/strong>",
			"in": "1",
			"out": "1",
			"description": "    <strong>triu(..., 1)<\/strong>. See also <strong>R<\/strong>. ",
			"brief": "upper triangular part, above diagonal",
			"inout": "1;  1"
		},
		{
			"source": "<strong>YR<\/strong>",
			"in": "1--2 (1 \/ 2)",
			"out": "1",
			"description": "    <strong>tril<\/strong>. See also <strong>ZR<\/strong>. ",
			"brief": "lower triangular part",
			"inout": "1--2 (1 \/ 2);  1"
		},
		{
			"source": "<strong>ZR<\/strong>",
			"in": "1",
			"out": "1",
			"description": "    <strong>tril(..., -1)<\/strong>. See also <strong>YR<\/strong>. ",
			"brief": "lower triangular part, below diagonal",
			"inout": "1;  1"
		},
		{
			"source": "<strong>S<\/strong>",
			"in": "1--3 (1)",
			"out": "1--2 (1 \/ second)",
			"description": "    sort an array (<strong>sort<\/strong>) \/ sort an array based on another. (i) \n    Single-array mode works like Matlab's <strong>sort<\/strong>. If 2 inputs, a \n    negative value of the second input corresponds to descending \n    order. If first input is a cell array and the first cell \n    contains a char array, the rest of the cells' contents are \n    converted to char. (ii) If the first input is a cell array and \n    the first cell contains a numeric array, single-array numeric \n    mode is used. The first input is linearized if it's not a \n    vector, and its contents are linearized for the purposes of \n    sorting. The first input is then sorted in lexicographic order, \n    ignoring other inputs. (iii) In two-array mode, this function \n    takes as first 2 inputs an array and a vector array which is not \n    char. If the first array is not a vector it is linearized. The \n    second vector is sorted and its order is applied to the first. \n    An optional third input specifies direction as a string, or as a \n    negative number in the non-singleton dimension of the second \n    vector. The outputs are the two sorted arrays. (In two-array \n    mode, if the two input arrays are scalar the result is the same \n    as if the second input is interpreted as dimension, \n    corresponding to single array mode). See also <strong>XS<\/strong> ",
			"brief": "sort",
			"inout": "1--3 (1);  1--2 (1 \/ second)"
		},
		{
			"source": "<strong>XS<\/strong>",
			"in": "1--2 (1)",
			"out": "1--2 (1)",
			"description": "    <strong>sortrows<\/strong>. See also <strong>S<\/strong> ",
			"brief": "sort rows",
			"inout": "1--2 (1);  1--2 (1)"
		},
		{
			"source": "<strong>YS<\/strong>",
			"in": "2--3 (2 \/ 3)",
			"out": "1",
			"description": "    <strong>circshift<\/strong>. If second input is a scalar and there's no third \n    input, the shift is applied along the first non-singleton \n    dimension. This function also allows first input a 2D array; \n    third input a scalar specifying dimension; and second input a \n    vector or array specifying the shift for each position in the \n    other dimension ",
			"brief": "circular shift",
			"inout": "2--3 (2 \/ 3);  1"
		},
		{
			"source": "<strong>ZS<\/strong>",
			"in": "1",
			"out": "1",
			"description": "    <strong>sign<\/strong> ",
			"brief": "sign function",
			"inout": "1;  1"
		},
		{
			"source": "<strong>YT<\/strong>",
			"in": "1--2 (2 \/ 2)",
			"out": "1",
			"description": "    <strong>toeplitz<\/strong> ",
			"brief": "Toeplitz matrix",
			"inout": "1--2 (2 \/ 2);  1"
		},
		{
			"source": "<strong>U<\/strong>",
			"in": "1",
			"out": "1",
			"description": "    <strong>str2num<\/strong> with content checking. If input is not char, it is \n    automatically converted to char. Then content checking is \n    applied. If it fails, <strong>[]<\/strong> is returned. Else <strong>str2num<\/strong> is applied. \n    If that fails, the input string is evaluated. If that also \n    fails, <strong>[]<\/strong> is returned ",
			"brief": "convert string matrix to numeric array, or to general array",
			"inout": "1;  1"
		},
		{
			"source": "<strong>XU<\/strong>",
			"in": "1",
			"out": "1",
			"description": "    <strong>str2double<\/strong> ",
			"brief": "convert string to double precision value",
			"inout": "1;  1"
		},
		{
			"source": "<strong>V<\/strong>",
			"in": "1--2 (1 \/ 2)",
			"out": "1",
			"description": "    <strong>num2str<\/strong> ",
			"brief": "convert numbers to a string",
			"inout": "1--2 (1 \/ 2);  1"
		},
		{
			"source": "<strong>W<\/strong>",
			"in": "1",
			"out": "1",
			"description": "    <strong>2.^(...)<\/strong> ",
			"brief": "2 raised to array, element-wise",
			"inout": "1;  1"
		},
		{
			"source": "<strong>XX<\/strong>",
			"in": "2--9 (2 \/ 3)",
			"out": "1--6 (according to specified keywords)",
			"description": "    <strong>regexp<\/strong>. With 2 inputs: <strong>regexp(..., ..., 'match')<\/strong>. If first or \n    second inputs are numeric they are converted to char. <strong>'names'<\/strong> \n    output is not supported. This function allows flag strings in \n    third and subsequent inputs to be replaced by numbers, as \n    follows: 1: <strong>'start'<\/strong>, 2: <strong>'split'<\/strong>, 3: <strong>'end'<\/strong>, 4: <strong>'once'<\/strong>, 5: \n    <strong>'tokenExtents'<\/strong>, 6: <strong>'tokens'<\/strong>, 7: <strong>'match'<\/strong> ",
			"brief": "match regular expression",
			"inout": "2--9 (2 \/ 3);  1--6 (according to specified keywords)"
		},
		{
			"source": "<strong>YX<\/strong>",
			"in": "3--5 (3 \/ 4)",
			"out": "1",
			"description": "    <strong>regexprep<\/strong>. If first, second or third inputs are numeric they are \n    converted to char ",
			"brief": "replace string using regular expression",
			"inout": "3--5 (3 \/ 4);  1"
		},
		{
			"source": "<strong>YY<\/strong>",
			"in": "0-- (0)",
			"out": "1",
			"description": "    <strong>inf<\/strong> function. If 0 inputs: produces literal <strong>inf<\/strong>. ",
			"brief": "infinity",
			"inout": "0-- (0);  1"
		},
		{
			"source": "<strong>ZY<\/strong>",
			"in": "1",
			"out": "1",
			"description": "    <strong>isinf<\/strong> ",
			"brief": "true for infinite elements",
			"inout": "1;  1"
		},
		{
			"source": "<strong>X[<\/strong>",
			"in": "2",
			"out": "1-- (2)",
			"description": "    <strong>ind2sub<\/strong> ",
			"brief": "convert linear index into subscripts",
			"inout": "2;  1-- (2)"
		},
		{
			"source": "<strong>\\<\/strong>",
			"in": "2",
			"out": "1--2 (1 \/ 2)",
			"description": "    <strong>mod<\/strong>, element-wise with singleton expansion. With 2 outputs: \n    second output is `floor(...\/...)`. ",
			"brief": "modulus\/quotient after division (element-wise, singleton expansion)",
			"inout": "2;  1--2 (1 \/ 2)"
		},
		{
			"source": "<strong>X\\<\/strong>",
			"in": "2 (2 \/ )",
			"out": "1",
			"description": "    <strong>mod(...-1)+1<\/strong>, element-wise with singleton expansion ",
			"brief": "modulus on the interval [1,divisor) (element-wise, singleton expansion)",
			"inout": "2 (2 \/ );  1"
		},
		{
			"source": "<strong>Y\\<\/strong>",
			"in": "2",
			"out": "1",
			"description": "    left matrix division, <strong>\\<\/strong> (<strong>mldivide<\/strong>) ",
			"brief": "left matrix division",
			"inout": "2;  1"
		},
		{
			"source": "<strong>]<\/strong>",
			"in": null,
			"out": null,
			"description": "    <strong>end<\/strong> (control flow). End loop or conditional branch. See also <strong>\"<\/strong>, \n    <strong>`<\/strong>, <strong>X`<\/strong>, <strong>?<\/strong> ",
			"brief": "end",
			"inout": ";  "
		},
		{
			"source": "<strong>X]<\/strong>",
			"in": "3-- (3)",
			"out": "1",
			"description": "    <strong>sub2ind<\/strong> ",
			"brief": "convert subscripts into linear index",
			"inout": "3-- (3);  1"
		},
		{
			"source": "<strong>^<\/strong>",
			"in": "2",
			"out": "1",
			"description": "    <strong>.^<\/strong> (<strong>power<\/strong>), element-wise with singleton expansion ",
			"brief": "array power (element-wise, singleton expansion)",
			"inout": "2;  1"
		},
		{
			"source": "<strong>X^<\/strong>",
			"in": "1",
			"out": "1",
			"description": "    <strong>sqrt<\/strong> ",
			"brief": "square root",
			"inout": "1;  1"
		},
		{
			"source": "<strong>Y^<\/strong>",
			"in": "2",
			"out": "1",
			"description": "    <strong>^<\/strong> (<strong>mpower<\/strong>) ",
			"brief": "matrix power",
			"inout": "2;  1"
		},
		{
			"source": "<strong>Z^<\/strong>",
			"in": "2",
			"out": "1",
			"description": "    (i) Given an array and a number n, computes the Cartesian power \n    of the array times itself n times. (ii) If the first input is a \n    number and the second input is an array of at least two \n    elements, the inputs are interpreted in reverse order. When \n    using this mode, caution is needed in case the second input \n    (array) may become a scalar, because then mode (i) will be used. \n    See also <strong>Z*<\/strong> ",
			"brief": "Cartesian power",
			"inout": "2;  1"
		},
		{
			"source": "<strong>_<\/strong>",
			"in": "1",
			"out": "1",
			"description": "    unary <strong>-<\/strong> (<strong>uminus<\/strong>) ",
			"brief": "unary minus",
			"inout": "1;  1"
		},
		{
			"source": "<strong>`<\/strong>",
			"in": null,
			"out": null,
			"description": "    do...while (control flow: loop). See also <strong>X`<\/strong>, <strong>]<\/strong>, <strong>@<\/strong>, <strong>.<\/strong>, <strong>X.<\/strong> ",
			"brief": "do...while",
			"inout": ";  "
		},
		{
			"source": "<strong>X`<\/strong>",
			"in": null,
			"out": null,
			"description": "    <strong>while<\/strong> (control flow: loop). See also <strong>`<\/strong>, <strong>]<\/strong>, <strong>@<\/strong>, <strong>.<\/strong>, <strong>X.<\/strong> ",
			"brief": "while",
			"inout": ";  "
		},
		{
			"source": "<strong>Y`<\/strong>",
			"in": "0",
			"out": "0--1 (0)",
			"description": "    <strong>tic<\/strong> ",
			"brief": "start a stopwatch timer",
			"inout": "0;  0--1 (0)"
		},
		{
			"source": "<strong>Z`<\/strong>",
			"in": "0--1 (0)",
			"out": "0--1 (1)",
			"description": "    <strong>toc<\/strong> ",
			"brief": "read the stopwatch timer",
			"inout": "0--1 (0);  0--1 (1)"
		},
		{
			"source": "<strong>a<\/strong>",
			"in": "1--2 (1 \/ 2)",
			"out": "1",
			"description": "    <strong>any<\/strong>. See also <strong>Xa<\/strong> ",
			"brief": "any",
			"inout": "1--2 (1 \/ 2);  1"
		},
		{
			"source": "<strong>Xa<\/strong>",
			"in": "1",
			"out": "1",
			"description": "    <strong>any(..., 1)<\/strong>. See also <strong>a<\/strong> ",
			"brief": "any, along first dimension",
			"inout": "1;  1"
		},
		{
			"source": "<strong>Ya<\/strong>",
			"in": "2--4 (2 \/ 3)",
			"out": "1",
			"description": "    <strong>padarray<\/strong>. It allows the first input to be <strong>char<\/strong>; and then the \n    output is also <strong>char<\/strong>. If the second input is <strong>logical<\/strong> or the pad \n    value is <strong>char<\/strong> they are converted to <strong>double<\/strong>. This function allows \n    flag strings in fourth input to be replaced by numbers, as \n    follows: 1: <strong>'pre'<\/strong>, 2: <strong>'post'<\/strong>, 3: <strong>'both'<\/strong> ",
			"brief": "pad array",
			"inout": "2--4 (2 \/ 3);  1"
		},
		{
			"source": "<strong>Za<\/strong>",
			"in": "3--4 (3 \/ 4)",
			"out": "1",
			"description": "    Converts the number represented by input 1 from the base \n    represented specified by input 2 to that of input 3. Each base \n    can be a number or a vector. In the first case the alphabet is \n    from 0 to that number minus 1. Non-valid digits in the first \n    input are discarded. An optional fourth input indicates number \n    of digits of the result. First input can be a matrix or a cell \n    array; and then the result is a matrix in which each row \n    corresponds to a row of the input matrix, or to a cell of the \n    input cell array in linear order ",
			"brief": "Convert numbers between bases",
			"inout": "3--4 (3 \/ 4);  1"
		},
		{
			"source": "<strong>b<\/strong>",
			"in": "0-- (3 \/ 4)",
			"out": "0",
			"description": "    bubble up element in stack ",
			"brief": "bubble up element in stack",
			"inout": "0-- (3 \/ 4);  0"
		},
		{
			"source": "<strong>Yb<\/strong>",
			"in": "1-- (1 \/ 2)",
			"out": "1--2 (1)",
			"description": "    (i) <strong>strsplit<\/strong>. If second input is numeric it is converted to \n    char. This function allows flag strings in third, fifth etc \n    inputs to be replaced by numbers, as follows: 1: \n    <strong>'CollapseDelimiters'<\/strong>, 2: <strong>'DelimiterType'<\/strong>, 3: \n    <strong>'RegularExpression'<\/strong>, 4: <strong>'Simple'<\/strong>. (ii) First input can be \n    numeric. In this mode the default delimiter is 0, and the \n    parameter <strong>'CollapseDelimiters'<\/strong> can be used. The second input \n    (delimiter) can be a single number or a numeric array, and in \n    the latter case each element is a possible delimiter. If the \n    first input is a row array the output will contain row arrays; \n    otherwise it will contain column arrays ",
			"brief": "split string or numeric array at delimiter",
			"inout": "1-- (1 \/ 2);  1--2 (1)"
		},
		{
			"source": "<strong>c<\/strong>",
			"in": "1-- (1)",
			"out": "1",
			"description": "    <strong>char<\/strong>. For cell array input, non-char cell contents are first \n    converted to char ",
			"brief": "convert to character array",
			"inout": "1-- (1);  1"
		},
		{
			"source": "<strong>Xc<\/strong>",
			"in": "3-- (3 \/ number of elements in stack)",
			"out": "1",
			"description": "    <strong>cat<\/strong> ",
			"brief": "concatenate arrays",
			"inout": "3-- (3 \/ number of elements in stack);  1"
		},
		{
			"source": "<strong>Yc<\/strong>",
			"in": "1-- (2 \/ number of elements in stack)",
			"out": "1",
			"description": "    <strong>strcat<\/strong>. Numeric inputs are converted to char ",
			"brief": "concatenate strings",
			"inout": "1-- (2 \/ number of elements in stack);  1"
		},
		{
			"source": "<strong>Zc<\/strong>",
			"in": "1--2 (1 \/ 2)",
			"out": "1",
			"description": "    <strong>strjoin<\/strong>. This function also allows input with numeric content. \n    The first cell of the first input determines char or numeric \n    mode. If that cell contains a char (resp. numeric) array, \n    numeric (resp. char) contents in other cells, as well as the \n    second input or its contents, are converted to char (resp. \n    double). (i) Char mode corresponds to <strong>strjoin<\/strong>. (ii) Numeric mode \n    is similar: it has a default delimiter, which is 0; or a single \n    delimiter may be specified, which may be a scalar or an array; \n    or a cell array of delimiters may be used. (i, ii) Both in char \n    and in numeric mode, non-vector arrays are linearized, and the \n    result is a row vector. Surplus delimiters are ignored ",
			"brief": "join cell array of strings or numbers into single vector",
			"inout": "1--2 (1 \/ 2);  1"
		},
		{
			"source": "<strong>d<\/strong>",
			"in": "1--3 (1 \/ 2)",
			"out": "1",
			"description": "    <strong>diff<\/strong> with second and third input interchanged: second specifies \n    dimension, third specifies difference order. ",
			"brief": "difference",
			"inout": "1--3 (1 \/ 2);  1"
		},
		{
			"source": "<strong>Xd<\/strong>",
			"in": "1--4 (1 \/ 2)",
			"out": "1--2 (1)",
			"description": "    If 1 input and 1 output: <strong>diag<\/strong>. Otherwise: <strong>spdiags<\/strong>, with char \n    inputs automatically converted to double ",
			"brief": "diagonal matrices and diagonals of a matrix",
			"inout": "1--4 (1 \/ 2);  1--2 (1)"
		},
		{
			"source": "<strong>Yd<\/strong>",
			"in": "1-- (2 \/ number of elements in stack)",
			"out": "1",
			"description": "    <strong>blkdiag<\/strong> ",
			"brief": "block diagonal concatenation",
			"inout": "1-- (2 \/ number of elements in stack);  1"
		},
		{
			"source": "<strong>Zd<\/strong>",
			"in": "1--2 (2 \/ 1)",
			"out": "1--3 (1)",
			"description": "    <strong>gcd<\/strong>, element-wise with singleton expansion. With 1 input and 1 \n    output, computes the greatest common divisor of all elements of \n    the input ",
			"brief": "greatest common divisor (element-wise, singleton expansion)",
			"inout": "1--2 (2 \/ 1);  1--3 (1)"
		},
		{
			"source": "<strong>e<\/strong>",
			"in": "1-- (2 \/ 1)",
			"out": "1",
			"description": "    With 1 input: <strong>squeeze<\/strong>. With more than 1 input: <strong>reshape<\/strong>. If \n    second input is logical, <strong>size<\/strong> is automatically applied to it. If \n    second input is a (non-logical) scalar, a final <strong>[]<\/strong> is implicit. \n    If size specification doesn't contain <strong>[]<\/strong> (explicit or implicit), \n    the first input is padded or truncated if needed; padding is \n    done with <strong>0<\/strong>, <strong>false<\/strong>, <strong>char(0)<\/strong> or <strong>{[]}<\/strong> according to type of first \n    input. If size specification contains <strong>[]<\/strong> (explicit or implicit), \n    the first input is padded if needed ",
			"brief": "reshape array \/ remove singleton dimensions",
			"inout": "1-- (2 \/ 1);  1"
		},
		{
			"source": "<strong>Ze<\/strong>",
			"in": "1",
			"out": "1",
			"description": "    <strong>exp<\/strong> ",
			"brief": "exponential",
			"inout": "1;  1"
		},
		{
			"source": "<strong>f<\/strong>",
			"in": "1--3 (1)",
			"out": "1--3 (1 \/ 2)",
			"description": "    <strong>find<\/strong> ",
			"brief": "find",
			"inout": "1--3 (1);  1--3 (1 \/ 2)"
		},
		{
			"source": "<strong>Xf<\/strong>",
			"in": "1--4 (2 \/ 1)",
			"out": "1",
			"description": "    (i) If 2 or more inputs: <strong>strfind<\/strong>. Works also when the first \n    input is a numeric array or a cell array of numeric arrays. In \n    this case each numeric array is linearized, and results are row \n    vectors. (ii) If 1 input: cell array of all substrings. Works \n    also for numeric or cell arrays ",
			"brief": "find one string within another \/ all substrings",
			"inout": "1--4 (2 \/ 1);  1"
		},
		{
			"source": "<strong>Yf<\/strong>",
			"in": "1",
			"out": "1",
			"description": "    <strong>factor<\/strong>. For input 1 it returns an empty array, not 1 like <strong>factor<\/strong> \n    does. For negative input, <strong>factor<\/strong> is applied to the absolute \n    value of the input (so input -1 produces 1). ",
			"brief": "prime factors",
			"inout": "1;  1"
		},
		{
			"source": "<strong>g<\/strong>",
			"in": "1",
			"out": "1",
			"description": "    <strong>logical<\/strong> \/ <strong>cell2mat<\/strong> ",
			"brief": "convert to logical, or from cell array to single array",
			"inout": "1;  1"
		},
		{
			"source": "<strong>Xg<\/strong>",
			"in": "1-- (2)",
			"out": "1-- (number of inputs)",
			"description": "    <strong>ndgrid<\/strong> ",
			"brief": "rectangular grid in N-D space",
			"inout": "1-- (2);  1-- (number of inputs)"
		},
		{
			"source": "<strong>Yg<\/strong>",
			"in": "1--3 (1)",
			"out": "1",
			"description": "    <strong>gamma<\/strong> \/ <strong>gammainc<\/strong> \/ <strong>betainc<\/strong>, depending on number of inputs ",
			"brief": "gamma, incomplete gamma or incomplete beta function",
			"inout": "1--3 (1);  1"
		},
		{
			"source": "<strong>Zg<\/strong>",
			"in": "1--2 (1 \/ 2)",
			"out": "1",
			"description": "    <strong>gammaln<\/strong> \/ <strong>betaln<\/strong>, depending on number of inputs ",
			"brief": "logarithm of gamma or beta function",
			"inout": "1--2 (1 \/ 2);  1"
		},
		{
			"source": "<strong>h<\/strong>",
			"in": "0-- (2 \/ number of elements in stack)",
			"out": "1",
			"description": "    <strong>horzcat<\/strong>. If inputs are matrices with non-matching sizes they are \n    linearized ",
			"brief": "horizontal concatenation",
			"inout": "0-- (2 \/ number of elements in stack);  1"
		},
		{
			"source": "<strong>Xh<\/strong>",
			"in": "0-- (number of elements in stack)",
			"out": "1",
			"description": "    concatenate into cell array (<strong>{..., ...}<\/strong>) ",
			"brief": "concatenate into cell array",
			"inout": "0-- (number of elements in stack);  1"
		},
		{
			"source": "<strong>Yh<\/strong>",
			"in": "1--2 (2 \/ 1)",
			"out": "1",
			"description": "    <strong>hankel<\/strong>. If any input is of type char: returns char output ",
			"brief": "Hankel matrix",
			"inout": "1--2 (2 \/ 1);  1"
		},
		{
			"source": "<strong>Zh<\/strong>",
			"in": "3",
			"out": "1",
			"description": "    <strong>hypergeom<\/strong> ",
			"brief": "hypergeometric function",
			"inout": "3;  1"
		},
		{
			"source": "<strong>i<\/strong>",
			"in": "0--2 (0)",
			"out": "1",
			"description": "    <strong>input<\/strong> with content checking. If 0 inputs: uses default prompt \n    string. See also <strong>j<\/strong>. ",
			"brief": "input",
			"inout": "0--2 (0);  1"
		},
		{
			"source": "<strong>Xi<\/strong>",
			"in": "1--5 (1)",
			"out": "1--2 (1)",
			"description": "    <strong>urlread<\/strong> ",
			"brief": "read contents or a URL as a string",
			"inout": "1--5 (1);  1--2 (1)"
		},
		{
			"source": "<strong>Yi<\/strong>",
			"in": "1-- (1)",
			"out": "1--3 (1)",
			"description": "    <strong>imread<\/strong> ",
			"brief": "read image from file",
			"inout": "1-- (1);  1--3 (1)"
		},
		{
			"source": "<strong>j<\/strong>",
			"in": "0--1 (0)",
			"out": "1",
			"description": "    <strong>input(..., 's')<\/strong>. If 0 inputs: uses default prompt string. See \n    also <strong>i<\/strong>. ",
			"brief": "input string",
			"inout": "0--1 (0);  1"
		},
		{
			"source": "<strong>Xj<\/strong>",
			"in": "1",
			"out": "1",
			"description": "    <strong>real<\/strong> ",
			"brief": "real part",
			"inout": "1;  1"
		},
		{
			"source": "<strong>Yj<\/strong>",
			"in": "1",
			"out": "1",
			"description": "    <strong>imag<\/strong> ",
			"brief": "imaginary part",
			"inout": "1;  1"
		},
		{
			"source": "<strong>Zj<\/strong>",
			"in": "1",
			"out": "1",
			"description": "    <strong>conj<\/strong> ",
			"brief": "complex conjugate",
			"inout": "1;  1"
		},
		{
			"source": "<strong>k<\/strong>",
			"in": "1",
			"out": "1",
			"description": "    <strong>lower<\/strong> for strings or cell arrays; <strong>floor<\/strong> for numerical arrays ",
			"brief": "convert string to lowercase \/ round towards minus infinity",
			"inout": "1;  1"
		},
		{
			"source": "<strong>Xk<\/strong>",
			"in": "1",
			"out": "1",
			"description": "    <strong>upper<\/strong> for strings or cell arrays of strings; <strong>ceil<\/strong> for numerical \n    arrays ",
			"brief": "convert string to uppercase \/ round towards infinity",
			"inout": "1;  1"
		},
		{
			"source": "<strong>Yk<\/strong>",
			"in": "2",
			"out": "1--3 (1)",
			"description": "    closest value in second input to each value in first input, in \n    terms of absolute difference. For equidistant values it picks \n    the one that appears first (in linear order) in the second \n    input. Second output gives resulting absolute differences. Third \n    output gives linear indices of selected elements ",
			"brief": "closest value",
			"inout": "2;  1--3 (1)"
		},
		{
			"source": "<strong>l<\/strong>",
			"in": "0-- (0 \/ 2)",
			"out": "1",
			"description": "    <strong>ones<\/strong> (if 0 inputs: produces output 1) ",
			"brief": "array of ones",
			"inout": "0-- (0 \/ 2);  1"
		},
		{
			"source": "<strong>Yl<\/strong>",
			"in": "1--2 (1 \/ 2)",
			"out": "1",
			"description": "    <strong>log<\/strong>. If 2 inputs: second input specifies logarithm base ",
			"brief": "logarithm",
			"inout": "1--2 (1 \/ 2);  1"
		},
		{
			"source": "<strong>Zl<\/strong>",
			"in": "1",
			"out": "1--2 (1)",
			"description": "    <strong>log2<\/strong> ",
			"brief": "base 2 logarithm",
			"inout": "1;  1--2 (1)"
		},
		{
			"source": "<strong>m<\/strong>",
			"in": "2--4 (2)",
			"out": "1--2 (1 \/ second)",
			"description": "    <strong>ismember<\/strong>. It also works for cell arrays with numeric content, or \n    with mixed char\/numeric content. See also <strong>Xm<\/strong> ",
			"brief": "true for set member",
			"inout": "2--4 (2);  1--2 (1 \/ second)"
		},
		{
			"source": "<strong>Xm<\/strong>",
			"in": "2--3 (2)",
			"out": "1--2 (1 \/ second)",
			"description": "    <strong>ismember(..., 'rows', ...)<\/strong>. See also <strong>m<\/strong> ",
			"brief": "true for set member, row-wise",
			"inout": "2--3 (2);  1--2 (1 \/ second)"
		},
		{
			"source": "<strong>Ym<\/strong>",
			"in": "1--4 (1 \/ 2)",
			"out": "1",
			"description": "    <strong>mean<\/strong>. This function allows flag strings in third and subsequent \n    inputs to be replaced by numbers, as follows: 1: <strong>'omitnan'<\/strong>, 2: \n    <strong>'includenan'<\/strong>, 3: <strong>'double'<\/strong>, 4: <strong>'native'<\/strong>, 5: <strong>'default'<\/strong> ",
			"brief": "mean value",
			"inout": "1--4 (1 \/ 2);  1"
		},
		{
			"source": "<strong>Zm<\/strong>",
			"in": "1--2 (2 \/ 1)",
			"out": "1",
			"description": "    <strong>lcm<\/strong>, element-wise with singleton expansion. With 1 input, \n    computes the least common multiple of all elements of the input ",
			"brief": "least common multiple (element-wise, singleton expansion)",
			"inout": "1--2 (2 \/ 1);  1"
		},
		{
			"source": "<strong>n<\/strong>",
			"in": "1",
			"out": "1",
			"description": "    <strong>numel<\/strong> ",
			"brief": "number of elements in array",
			"inout": "1;  1"
		},
		{
			"source": "<strong>Xn<\/strong>",
			"in": "1--2 (2 \/ 1)",
			"out": "1",
			"description": "    (i) If 2 inputs: <strong>nchoosek<\/strong>. This interprets first input as \n    number(s). If the inputs are arrays, the function is computed \n    element-wise with singleton expansion. For values <strong>n<\/strong> and <strong>k<\/strong> in \n    first and second inputs, if <strong>n<\/strong> is less than <strong>k<\/strong> the result is <strong>0<\/strong>. \n    (ii) If 1 input: multinomial coefficient. The input contains the \n    lower terms; their sum is the upper term. See also <strong>XN<\/strong> ",
			"brief": "binomial coefficient (number of combinations)",
			"inout": "1--2 (2 \/ 1);  1"
		},
		{
			"source": "<strong>Yn<\/strong>",
			"in": "1--5 (2 \/ 4)",
			"out": "1",
			"description": "    (i) If 1 input: <strong>poly<\/strong>. (ii) If 2 or more inputs: <strong>interp1<\/strong>. <strong>'pp'<\/strong> \n    option not supported. This function allows flag strings in the \n    fourth input to be replaced by numbers, as follows: 1: <strong>'linear'<\/strong>, \n    2: <strong>'nearest'<\/strong>, 3: <strong>'next'<\/strong>, 4: <strong>'previous'<\/strong>, 5: <strong>'spline'<\/strong>, 6: <strong>'pchip'<\/strong>, \n    7: <strong>'cubic'<\/strong>, 8: <strong>'v5cubic'<\/strong> ",
			"brief": "interpolation (table lookup) \/ convert roots to polynomial",
			"inout": "1--5 (2 \/ 4);  1"
		},
		{
			"source": "<strong>o<\/strong>",
			"in": "1--3 (1)",
			"out": "1",
			"description": "    <strong>double<\/strong>. For cell array input behaves similarly to <strong>char<\/strong>: \n    linearizes cell array, converts cell contents to double and \n    concatenates vertically, padding if needed. By default, padding \n    is with zeros on the left. Optional second input indicates fill \n    side: left if it evaluates to <strong>false<\/strong>, right if it evaluates to \n    <strong>true<\/strong>. Third optional input specifies fill value ",
			"brief": "convert to double precision array",
			"inout": "1--3 (1);  1"
		},
		{
			"source": "<strong>Xo<\/strong>",
			"in": "1",
			"out": "1",
			"description": "    <strong>int64<\/strong> ",
			"brief": "convert to signed 64-bit integer",
			"inout": "1;  1"
		},
		{
			"source": "<strong>Yo<\/strong>",
			"in": "1--3 (1 \/ 2)",
			"out": "1",
			"description": "    (i) For numeric arrays: <strong>round<\/strong>. Third input can be a number \n    instead of a string, as follows: 1: <strong>'signiticant'<\/strong>, 2: \n    <strong>'decimals'<\/strong>. (ii) For strings or cell arrays: change case ",
			"brief": "round towards nearest decimal or integer",
			"inout": "1--3 (1 \/ 2);  1"
		},
		{
			"source": "<strong>Zo<\/strong>",
			"in": "1",
			"out": "1",
			"description": "    <strong>fix<\/strong> ",
			"brief": "round to nearest integer towards zero",
			"inout": "1;  1"
		},
		{
			"source": "<strong>p<\/strong>",
			"in": "1--3 (1 \/ 2)",
			"out": "1",
			"description": "    <strong>prod<\/strong>. If first input is <strong>char<\/strong> it is converted to <strong>double<\/strong>. See also \n    <strong>Xp<\/strong> ",
			"brief": "product of elements",
			"inout": "1--3 (1 \/ 2);  1"
		},
		{
			"source": "<strong>Xp<\/strong>",
			"in": "1--3 (1)",
			"out": "1",
			"description": "    <strong>prod(..., 1, ...)<\/strong>. If first input is <strong>char<\/strong> it is converted to \n    <strong>double<\/strong>. See also <strong>p<\/strong>. ",
			"brief": "product along first dimension",
			"inout": "1--3 (1);  1"
		},
		{
			"source": "<strong>Yp<\/strong>",
			"in": "1--4 (1 \/ 2)",
			"out": "1",
			"description": "    <strong>cumprod<\/strong>. Allows first input to be char. If 3 numeric inputs: the \n    third input is interpreted as a minimum which is applied after \n    the product at each position. If 4 numeric inputs: last two \n    inputs are minimum and maximum respectively ",
			"brief": "cumulative product",
			"inout": "1--4 (1 \/ 2);  1"
		},
		{
			"source": "<strong>Zp<\/strong>",
			"in": "1",
			"out": "1",
			"description": "    For input with non-negative entries: <strong>isprime<\/strong>. For input with \n    non-positive entries: Euler's totient function for absolute \n    value of each entry ",
			"brief": "is prime \/ totient function",
			"inout": "1;  1"
		},
		{
			"source": "<strong>q<\/strong>",
			"in": "1",
			"out": "1",
			"description": "    <strong>(...)-1<\/strong> ",
			"brief": "decrement by 1",
			"inout": "1;  1"
		},
		{
			"source": "<strong>Xq<\/strong>",
			"in": "2--3 (2 \/ 3)",
			"out": "1",
			"description": "    <strong>quantile<\/strong> ",
			"brief": "quantiles of a sample",
			"inout": "2--3 (2 \/ 3);  1"
		},
		{
			"source": "<strong>Yq<\/strong>",
			"in": "1",
			"out": "1",
			"description": "    For input with positive entries: n-th prime for each value n in \n    the input array. For input with non-positive entries: next prime \n    for absolute value of each entry ",
			"brief": "n-th prime \/ next prime",
			"inout": "1;  1"
		},
		{
			"source": "<strong>Zq<\/strong>",
			"in": "1",
			"out": "1",
			"description": "    <strong>primes<\/strong> ",
			"brief": "prime numbers up to a given value",
			"inout": "1;  1"
		},
		{
			"source": "<strong>r<\/strong>",
			"in": "0-- (0)",
			"out": "1",
			"description": "    <strong>rand<\/strong> ",
			"brief": "uniformly distributed pseudorandom numbers",
			"inout": "0-- (0);  1"
		},
		{
			"source": "<strong>Xr<\/strong>",
			"in": "0-- (0)",
			"out": "1",
			"description": "    <strong>randn<\/strong> ",
			"brief": "normally distributed pseudorandom numbers",
			"inout": "0-- (0);  1"
		},
		{
			"source": "<strong>Yr<\/strong>",
			"in": "1-- (1)",
			"out": "1",
			"description": "    <strong>randi<\/strong> ",
			"brief": "pseudorandom integers from uniform discrete distribution",
			"inout": "1-- (1);  1"
		},
		{
			"source": "<strong>Zr<\/strong>",
			"in": "2--4 (2 \/ 3)",
			"out": "1",
			"description": "    <strong>randsample<\/strong>. Does not support stream specification ",
			"brief": "random sample",
			"inout": "2--4 (2 \/ 3);  1"
		},
		{
			"source": "<strong>s<\/strong>",
			"in": "1--4 (1 \/ 2)",
			"out": "1",
			"description": "    <strong>sum<\/strong>. This function allows flag strings in third and subsequent \n    inputs to be replaced by numbers, as follows: 1: <strong>'omitnan'<\/strong>, 2: \n    <strong>'includenan'<\/strong>, 3: <strong>'double'<\/strong>, 4: <strong>'native'<\/strong>, 5: <strong>'default'<\/strong>. See also \n    <strong>Xs<\/strong> ",
			"brief": "sum",
			"inout": "1--4 (1 \/ 2);  1"
		},
		{
			"source": "<strong>Xs<\/strong>",
			"in": "1--3 (1)",
			"out": "1",
			"description": "    <strong>sum(..., 1, ...)<\/strong>. This function allows flag strings in third and \n    subsequent inputs to be replaced by numbers, as follows: 1: \n    <strong>'omitnan'<\/strong>, 2: <strong>'includenan'<\/strong>, 3: <strong>'double'<\/strong>, 4: <strong>'native'<\/strong>, 5: \n    <strong>'default'<\/strong>. See also <strong>s<\/strong> ",
			"brief": "sum along first dimension.",
			"inout": "1--3 (1);  1"
		},
		{
			"source": "<strong>Ys<\/strong>",
			"in": "1--4 (1 \/ 2)",
			"out": "1",
			"description": "    <strong>cumsum<\/strong>. Allows first input to be char. Optional third and fourth \n    numerical scalar inputs are interpreted as minimum and maximum \n    values, which are applied after the sum at each position. These \n    can be substituted by a 2-element numerical array as second or \n    third input ",
			"brief": "cumulative sum",
			"inout": "1--4 (1 \/ 2);  1"
		},
		{
			"source": "<strong>Zs<\/strong>",
			"in": "1--4 (1 \/ 2)",
			"out": "1",
			"description": "    <strong>std<\/strong> ",
			"brief": "standard deviation",
			"inout": "1--4 (1 \/ 2);  1"
		},
		{
			"source": "<strong>t<\/strong>",
			"in": "0-- (1)",
			"out": "0",
			"description": "    duplicate elements in stack. The duplicated elements are those \n    specified as inputs ",
			"brief": "duplicate elements",
			"inout": "0-- (1);  0"
		},
		{
			"source": "<strong>Zt<\/strong>",
			"in": "3",
			"out": "1",
			"description": "    <strong>strrep<\/strong>. The first input can be a numeric array (not a cell array \n    of numeric arrays). In this case the other inputs can be char or \n    numeric (not cell); each input array is linearized; result is a \n    row vector; and result is char if third input is, even if no \n    substitutions have been actually done ",
			"brief": "replace substring with another",
			"inout": "3;  1"
		},
		{
			"source": "<strong>u<\/strong>",
			"in": "1--4 (1)",
			"out": "1--4 (1)",
			"description": "    <strong>unique<\/strong>, with <strong>'stable'<\/strong> option by default. It includes a fourth \n    output with the count for each unique element. It also allows \n    cell array input with numeric content, or mixed char\/numeric \n    content. In this case it only works with a single output, either \n    in sorted or stable mode. This function allows flag strings in \n    second and subsequent inputs to be replaced by numbers, as \n    follows: 1: <strong>'stable'<\/strong>, 2: <strong>'sorted'<\/strong>, 3: <strong>'last'<\/strong>, 4: <strong>'first'<\/strong>, 5: \n    <strong>'rows'<\/strong>. See also <strong>Xu<\/strong> ",
			"brief": "unique",
			"inout": "1--4 (1);  1--4 (1)"
		},
		{
			"source": "<strong>Xu<\/strong>",
			"in": "1--3 (1)",
			"out": "1--4 (1)",
			"description": "    <strong>unique(..., 'rows', ...)<\/strong>, with <strong>'stable'<\/strong> option by default. It \n    includes a fourth output with the count for each unique row. \n    This function allows flag strings in second and subsequent \n    inputs to be replaced by numbers, as follows: 1: <strong>'stable'<\/strong>, 2: \n    <strong>'sorted'<\/strong>, 3: <strong>'last'<\/strong>, 4: <strong>'first'<\/strong>. See also <strong>u<\/strong> ",
			"brief": "unique rows",
			"inout": "1--3 (1);  1--4 (1)"
		},
		{
			"source": "<strong>Zu<\/strong>",
			"in": "1--2 (1)",
			"out": "1",
			"description": "    <strong>strjust<\/strong> ",
			"brief": "justify character array",
			"inout": "1--2 (1);  1"
		},
		{
			"source": "<strong>v<\/strong>",
			"in": "0-- (number of elements in stack \/ 2)",
			"out": "1",
			"description": "    <strong>vertcat<\/strong>. If inputs are matrices with non-matching sizes they are \n    linearized ",
			"brief": "vertical concatenation",
			"inout": "0-- (number of elements in stack \/ 2);  1"
		},
		{
			"source": "<strong>Yv<\/strong>",
			"in": "1",
			"out": "1",
			"description": "    <strong>strtrim<\/strong> ",
			"brief": "remove insignificant whitespace",
			"inout": "1;  1"
		},
		{
			"source": "<strong>Zv<\/strong>",
			"in": "1",
			"out": "1",
			"description": "    <strong>deblank<\/strong> ",
			"brief": "remove trailing blanks",
			"inout": "1;  1"
		},
		{
			"source": "<strong>w<\/strong>",
			"in": "0-- (2)",
			"out": "0",
			"description": "    swap elements in stack ",
			"brief": "swap elements in stack",
			"inout": "0-- (2);  0"
		},
		{
			"source": "<strong>x<\/strong>",
			"in": "0-- (1)",
			"out": "0",
			"description": "    delete from stack ",
			"brief": "delete",
			"inout": "0-- (1);  0"
		},
		{
			"source": "<strong>Xx<\/strong>",
			"in": "0",
			"out": "0",
			"description": "    <strong>clc<\/strong> ",
			"brief": "clear window",
			"inout": "0;  0"
		},
		{
			"source": "<strong>y<\/strong>",
			"in": "0-- (2 \/ 3)",
			"out": "0",
			"description": "    duplicate one element in stack. The duplicated element is the \n    lowest among those specified as inputs ",
			"brief": "duplicate element",
			"inout": "0-- (2 \/ 3);  0"
		},
		{
			"source": "<strong>Xy<\/strong>",
			"in": "1--4 (1)",
			"out": "1",
			"description": "    <strong>eye<\/strong> ",
			"brief": "eye (matrix with ones on diagonal and zeros elsewhere)",
			"inout": "1--4 (1);  1"
		},
		{
			"source": "<strong>Yy<\/strong>",
			"in": "2",
			"out": "1",
			"description": "    <strong>hypot<\/strong>, element-wise with singleton expansion ",
			"brief": "hypotenuse (element-wise, singleton expansion)",
			"inout": "2;  1"
		},
		{
			"source": "<strong>Zy<\/strong>",
			"in": "1--2 (1)",
			"out": "1-- (1)",
			"description": "    <strong>size<\/strong> ",
			"brief": "size",
			"inout": "1--2 (1);  1-- (1)"
		},
		{
			"source": "<strong>z<\/strong>",
			"in": "1",
			"out": "1",
			"description": "    <strong>nnz<\/strong> ",
			"brief": "number of nonzero elements",
			"inout": "1;  1"
		},
		{
			"source": "<strong>Xz<\/strong>",
			"in": "1",
			"out": "1",
			"description": "    <strong>nonzeros<\/strong>. If input is a string or cell array strings: remove \n    whitespace, including <strong>char(0)<\/strong> ",
			"brief": "nonzero elements \/ remove whitespace",
			"inout": "1;  1"
		},
		{
			"source": "<strong>X{<\/strong>",
			"in": "1--2 (1 \/ 2)",
			"out": "1",
			"description": "    <strong>num2cell<\/strong> ",
			"brief": "convert numeric array into cell array",
			"inout": "1--2 (1 \/ 2);  1"
		},
		{
			"source": "<strong>Y{<\/strong>",
			"in": "2-- (3 \/ 2)",
			"out": "1",
			"description": "    <strong>mat2cell<\/strong> ",
			"brief": "break up array into cell array of subarrays",
			"inout": "2-- (3 \/ 2);  1"
		},
		{
			"source": "<strong>Z{<\/strong>",
			"in": "1",
			"out": "1",
			"description": "    <strong>mat2cell(x, ones(size(x,1),1), size(x,2),...,size(x,ndims(x)))<\/strong>. \n    It's a generalization of <strong>cellstr<\/strong> that works for numeric, logical \n    or char arrays of any number of dimensions ",
			"brief": "cell array of first-dimension slices from array",
			"inout": "1;  1"
		},
		{
			"source": "<strong>|<\/strong>",
			"in": "1--2 (1 \/ 2)",
			"out": "1",
			"description": "    If 1 input: <strong>abs<\/strong>. If 2 inputs, second input non-zero: <strong>norm<\/strong>. If 2 \n    inputs, second input zero: <strong>det<\/strong>, or <strong>sqrt(det(A*A.'))<\/strong> for first \n    input <strong>A<\/strong> non-square ",
			"brief": "absolute value \/ norm \/ determinant",
			"inout": "1--2 (1 \/ 2);  1"
		},
		{
			"source": "<strong>X|<\/strong>",
			"in": "2--4 (2 \/ 3)",
			"out": "1--3 (1)",
			"description": "    <strong>union<\/strong>. Uses the <strong>'stable'<\/strong> flag by default. If one input is char \n    and the other is numeric, the latter is converted to char. This \n    function allows flag strings in third and subsequent inputs to \n    be replaced by numbers, as follows: 1: <strong>'rows'<\/strong>, 2: <strong>'stable'<\/strong>, 3: \n    <strong>'sorted'<\/strong> ",
			"brief": "set union",
			"inout": "2--4 (2 \/ 3);  1--3 (1)"
		},
		{
			"source": "<strong>Y|<\/strong>",
			"in": "0-- (2 \/ number of elements in stack)",
			"out": "1",
			"description": "    <strong>|<\/strong> (<strong>or<\/strong>), element-wise with singleton expansion ",
			"brief": "logical 'or' (element-wise, singleton expansion)",
			"inout": "0-- (2 \/ number of elements in stack);  1"
		},
		{
			"source": "<strong>Z|<\/strong>",
			"in": "2--3 (2)",
			"out": "1",
			"description": "    <strong>bitor<\/strong>, element-wise with singleton expansion. If first or second \n    inputs are <strong>char<\/strong> they are automatically converted to <strong>double<\/strong> ",
			"brief": "bit-wise logical 'or' (element-wise, singleton expansion)",
			"inout": "2--3 (2);  1"
		},
		{
			"source": "<strong>}<\/strong>",
			"in": null,
			"out": null,
			"description": "    <strong>else<\/strong> (control flow: conditional branch). See also <strong>?<\/strong> ",
			"brief": "else",
			"inout": ";  "
		},
		{
			"source": "<strong>Z}<\/strong>",
			"in": "1--2 (1 \/ 2)",
			"out": "0-- (number of subarrays that will be produced)",
			"description": "    split array into subarrays along the first non-singleton \n    dimension. With 2 inputs: split into subarrays along the \n    dimension indicated by the second input ",
			"brief": "split array",
			"inout": "1--2 (1 \/ 2);  0-- (number of subarrays that will be produced)"
		},
		{
			"source": "<strong>~<\/strong>",
			"in": "1",
			"out": "1",
			"description": "    <strong>~<\/strong> (<strong>not<\/strong>) ",
			"brief": "logical 'not' (element-wise)",
			"inout": "1;  1"
		},
		{
			"source": "<strong>X~<\/strong>",
			"in": "2--4 (2 \/ 3)",
			"out": "1--3 (1)",
			"description": "    <strong>setxor<\/strong>. Uses the <strong>'stable'<\/strong> flag by default. If one input is char \n    and the other is numeric, the latter is converted to char. This \n    function allows flag strings in third and subsequent inputs to \n    be replaced by numbers, as follows: 1: <strong>'rows'<\/strong>, 2: <strong>'stable'<\/strong>, 3: \n    <strong>'sorted'<\/strong> ",
			"brief": "set exclusive-or",
			"inout": "2--4 (2 \/ 3);  1--3 (1)"
		},
		{
			"source": "<strong>Y~<\/strong>",
			"in": "2",
			"out": "1",
			"description": "    <strong>xor<\/strong>, element-wise with singleton expansion ",
			"brief": "logical 'xor' (element-wise, singleton expansion)",
			"inout": "2;  1"
		},
		{
			"source": "<strong>Z~<\/strong>",
			"in": "2--3 (2)",
			"out": "1",
			"description": "    <strong>bitxor<\/strong>, element-wise with singleton expansion. If first or \n    second inputs are <strong>char<\/strong> they are automatically converted to \n    <strong>double<\/strong> ",
			"brief": "bit-wise logical 'xor' (element-wise, singleton expanstion)",
			"inout": "2--3 (2);  1"
		}
	]
}
